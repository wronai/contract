/**
 * Generation Log Writer
 * 
 * Generuje logi w formacie .rcl.md dokumentujÄ…ce proces generacji kodu.
 * 
 * @version 2.2.0
 */

import * as fs from 'fs';
import * as path from 'path';
import { ContractAI, GeneratedCode, PipelineResult, StageResult } from '../types';

// ============================================================================
// TYPES
// ============================================================================

export interface GenerationLogEntry {
  timestamp: Date;
  contract: ContractAI;
  generatedCode: GeneratedCode;
  pipelineResult: PipelineResult;
  prompt?: string;
  model?: string;
}

export interface LogWriterOptions {
  outputDir: string;
  language?: 'pl' | 'en';
}

// ============================================================================
// LABELS
// ============================================================================

const LABELS = {
  pl: {
    property: 'WÅ‚aÅ›ciwoÅ›Ä‡',
    value: 'WartoÅ›Ä‡',
    version: 'Wersja',
    created: 'Utworzono',
    time: 'Czas',
    model: 'Model',
    files: 'Pliki',
    entities: 'Encje',
    stages: 'Etapy walidacji',
    passed: 'Zaliczone',
    failed: 'Niezaliczone',
    generation: 'Generacja',
    validation: 'Walidacja',
    generatedFiles: 'Wygenerowane pliki',
    validationPipeline: 'Pipeline walidacji',
    contract: 'Kontrakt',
    generatedBy: 'Wygenerowano przez Reclapp Contract AI',
  },
  en: {
    property: 'Property',
    value: 'Value',
    version: 'Version',
    created: 'Created',
    time: 'Time',
    model: 'Model',
    files: 'Files',
    entities: 'Entities',
    stages: 'Validation Stages',
    passed: 'Passed',
    failed: 'Failed',
    generation: 'Generation',
    validation: 'Validation',
    generatedFiles: 'Generated Files',
    validationPipeline: 'Validation Pipeline',
    contract: 'Contract',
    generatedBy: 'Generated by Reclapp Contract AI',
  },
};

// ============================================================================
// LOG WRITER
// ============================================================================

/**
 * Zapisuje log generacji w formacie .rcl.md
 */
export class GenerationLogWriter {
  private options: LogWriterOptions;
  private L: typeof LABELS['pl'];

  constructor(options: LogWriterOptions) {
    this.options = options;
    this.L = LABELS[options.language || 'en'];
  }

  /**
   * Zapisuje log generacji
   */
  writeLog(entry: GenerationLogEntry): string {
    const { contract, generatedCode, pipelineResult } = entry;
    const now = entry.timestamp;
    const dateStr = now.toISOString().split('T')[0];
    const timeStr = now.toTimeString().split(' ')[0];

    const appName = contract.definition?.app?.name || 'Application';
    const version = contract.definition?.app?.version || '1.0.0';
    const entities = contract.definition?.entities || [];

    // Build markdown content
    let md = this.buildHeader(appName, version);
    md += this.buildMetadata(entry, dateStr, timeStr, entities.length);
    md += this.buildGenerationSection(generatedCode);
    md += this.buildValidationSection(pipelineResult);
    md += this.buildContractSection(contract);
    md += this.buildActionsSection(entry, now);
    md += this.buildFooter();

    // Write to file
    const filename = this.generateFilename(appName, now);
    const filePath = path.join(this.options.outputDir, filename);

    fs.mkdirSync(this.options.outputDir, { recursive: true });
    fs.writeFileSync(filePath, md, 'utf-8');

    return filePath;
  }

  private buildHeader(appName: string, version: string): string {
    return `# ${appName}

> Generated by Reclapp Contract AI v2.2.0

`;
  }

  private buildMetadata(
    entry: GenerationLogEntry,
    dateStr: string,
    timeStr: string,
    entityCount: number
  ): string {
    const { generatedCode, pipelineResult } = entry;

    return `## Metadata

| ${this.L.property} | ${this.L.value} |
|----------|-------|
| ${this.L.version} | ${entry.contract.definition?.app?.version || '1.0.0'} |
| ${this.L.created} | ${dateStr} |
| ${this.L.time} | ${timeStr} |
| ${this.L.model} | ${entry.model || 'simulated'} |
| ${this.L.files} | ${generatedCode.files.length} |
| ${this.L.entities} | ${entityCount} |
| ${this.L.stages} | ${pipelineResult.stages.length} |
| ${this.L.passed} | ${pipelineResult.summary.passedStages}/${pipelineResult.stages.length} |

---

`;
  }

  private buildGenerationSection(generatedCode: GeneratedCode): string {
    let md = `## ðŸ“¦ ${this.L.generatedFiles}

`;

    for (const file of generatedCode.files) {
      const lang = this.getLanguageFromPath(file.path);
      md += `### \`${file.path}\`

\`\`\`${lang}
${file.content.substring(0, 500)}${file.content.length > 500 ? '\n// ... (truncated)' : ''}
\`\`\`

`;
    }

    md += `---

`;
    return md;
  }

  private buildValidationSection(pipelineResult: PipelineResult): string {
    let md = `## âœ… ${this.L.validationPipeline}

| Stage | Status | Time |
|-------|--------|------|
`;

    for (const stage of pipelineResult.stages) {
      const status = stage.passed ? 'âœ… PASSED' : 'âŒ FAILED';
      md += `| ${stage.stage} | ${status} | ${stage.timeMs}ms |\n`;
    }

    md += `
`;

    // Add errors if any
    const failedStages = pipelineResult.stages.filter(s => !s.passed);
    if (failedStages.length > 0) {
      md += `### Errors

`;
      for (const stage of failedStages) {
        for (const error of stage.errors) {
          md += `- **${stage.stage}**: ${error.message}\n`;
        }
      }
      md += `
`;
    }

    md += `---

`;
    return md;
  }

  private buildContractSection(contract: ContractAI): string {
    let md = `## ðŸ“œ ${this.L.contract}

\`\`\`typescript
// Contract AI Definition
export const contract = {
  definition: {
    app: ${JSON.stringify(contract.definition?.app || {}, null, 2).replace(/\n/g, '\n    ')},
    entities: [
${(contract.definition?.entities || []).map(e => `      "${e.name}"`).join(',\n')}
    ]
  },
  generation: {
    techStack: ${JSON.stringify(contract.generation?.techStack || {}, null, 2).replace(/\n/g, '\n    ')}
  }
};
\`\`\`

---

`;
    return md;
  }

  private buildActionsSection(entry: GenerationLogEntry, now: Date): string {
    return `## ðŸ“œ Actions

<!-- reclapp:actions -->
\`\`\`action
timestamp: ${now.toISOString()}
type: contract-ai-generation
model: ${entry.model || 'simulated'}
files: ${entry.generatedCode.files.length}
stages: ${entry.pipelineResult.stages.length}
passed: ${entry.pipelineResult.summary.passedStages}
result: ${entry.pipelineResult.passed ? 'success' : 'failed'}
\`\`\`

---

`;
  }

  private buildFooter(): string {
    return `*${this.L.generatedBy}*
`;
  }

  private generateFilename(appName: string, now: Date): string {
    const kebab = appName
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/\s+/g, '-')
      .toLowerCase();
    const timestamp = now.toISOString().replace(/[:.]/g, '-');
    return `${kebab}_${timestamp}.rcl.md`;
  }

  private getLanguageFromPath(filePath: string): string {
    if (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) return 'typescript';
    if (filePath.endsWith('.js') || filePath.endsWith('.jsx')) return 'javascript';
    if (filePath.endsWith('.json')) return 'json';
    if (filePath.endsWith('.css')) return 'css';
    if (filePath.endsWith('.html')) return 'html';
    if (filePath.includes('Dockerfile')) return 'dockerfile';
    return 'text';
  }
}

// ============================================================================
// FACTORY
// ============================================================================

export function createGenerationLogWriter(options: LogWriterOptions): GenerationLogWriter {
  return new GenerationLogWriter(options);
}
