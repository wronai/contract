/**
 * Generation Log Writer
 * 
 * Generuje logi w formacie .rcl.md dokumentujÄ…ce proces generacji kodu.
 * 
 * @version 2.4.1
 */

import * as fs from 'fs';
import * as path from 'path';
import { ContractAI, GeneratedCode, PipelineResult, StageResult } from '../types';

// ============================================================================
// TYPES
// ============================================================================

export interface GenerationLogEntry {
  timestamp: Date;
  contract: ContractAI;
  generatedCode: GeneratedCode;
  pipelineResult: PipelineResult;
  prompt?: string;
  contractFile?: string;
  outputDir?: string;
  cliArgs?: {
    maxIterations?: number;
    dryRun?: boolean;
    verbose?: boolean;
  };
  events?: Array<{
    at: string;
    step: string;
    details?: string;
  }>;
  iterationHistory?: Array<{
    iteration: number;
    passed: boolean;
    errorCount: number;
    warningCount: number;
    filesChanged: string[];
    timeMs: number;
  }>;
  model?: string;
}

export interface LogWriterOptions {
  outputDir: string;
  language?: 'pl' | 'en';
}

// ============================================================================
// LABELS
// ============================================================================

const LABELS = {
  pl: {
    property: 'WÅ‚aÅ›ciwoÅ›Ä‡',
    value: 'WartoÅ›Ä‡',
    version: 'Wersja',
    created: 'Utworzono',
    time: 'Czas',
    model: 'Model',
    files: 'Pliki',
    entities: 'Encje',
    stages: 'Etapy walidacji',
    passed: 'Zaliczone',
    failed: 'Niezaliczone',
    generation: 'Generacja',
    validation: 'Walidacja',
    generatedFiles: 'Wygenerowane pliki',
    validationPipeline: 'Pipeline walidacji',
    contract: 'Kontrakt',
    generatedBy: 'Wygenerowano przez Reclapp Contract AI',
  },
  en: {
    property: 'Property',
    value: 'Value',
    version: 'Version',
    created: 'Created',
    time: 'Time',
    model: 'Model',
    files: 'Files',
    entities: 'Entities',
    stages: 'Validation Stages',
    passed: 'Passed',
    failed: 'Failed',
    generation: 'Generation',
    validation: 'Validation',
    generatedFiles: 'Generated Files',
    validationPipeline: 'Validation Pipeline',
    contract: 'Contract',
    generatedBy: 'Generated by Reclapp Contract AI',
  },
};

// ============================================================================
// LOG WRITER
// ============================================================================

/**
 * Zapisuje log generacji w formacie .rcl.md
 */
export class GenerationLogWriter {
  private options: LogWriterOptions;
  private L: typeof LABELS['pl'];

  constructor(options: LogWriterOptions) {
    this.options = options;
    this.L = LABELS[options.language || 'en'];
  }

  /**
   * Zapisuje log generacji
   */
  writeLog(entry: GenerationLogEntry): string {
    const { contract, generatedCode, pipelineResult } = entry;
    const now = entry.timestamp;
    const dateStr = now.toISOString().split('T')[0];
    const timeStr = now.toTimeString().split(' ')[0];

    const appName = contract.definition?.app?.name || 'Application';
    const version = contract.definition?.app?.version || '1.0.0';
    const entities = contract.definition?.entities || [];

    // Build markdown content
    let md = this.buildHeader(appName, version);
    md += this.buildMetadata(entry, dateStr, timeStr, entities.length);
    md += this.buildRunSection(entry);
    md += this.buildGenerationSection(generatedCode);
    md += this.buildValidationSection(pipelineResult);
    md += this.buildIterationSection(entry);
    md += this.buildNextStepsSection(entry);
    md += this.buildContractSection(contract);
    md += this.buildActionsSection(entry, now);
    md += this.buildFooter();

    // Write to file
    const filename = this.generateFilename(appName, now);
    const filePath = path.join(this.options.outputDir, filename);

    fs.mkdirSync(this.options.outputDir, { recursive: true });
    fs.writeFileSync(filePath, md, 'utf-8');

    return filePath;
  }

  private buildHeader(appName: string, version: string): string {
    return `# ${appName}

> Generated by Reclapp Contract AI v2.4.1

`;
  }

  private buildMetadata(
    entry: GenerationLogEntry,
    dateStr: string,
    timeStr: string,
    entityCount: number
  ): string {
    const { generatedCode, pipelineResult } = entry;

    return `## Metadata

| ${this.L.property} | ${this.L.value} |
|----------|-------|
| ${this.L.version} | ${entry.contract.definition?.app?.version || '1.0.0'} |
| ${this.L.created} | ${dateStr} |
| ${this.L.time} | ${timeStr} |
| ${this.L.model} | ${entry.model || 'simulated'} |
| ${this.L.files} | ${generatedCode.files.length} |
| ${this.L.entities} | ${entityCount} |
| ${this.L.stages} | ${pipelineResult.stages.length} |
| ${this.L.passed} | ${pipelineResult.summary.passedStages}/${pipelineResult.stages.length} |

---

`;
  }

  private buildRunSection(entry: GenerationLogEntry): string {
    let md = `## ðŸ§­ Run

`;

    if (entry.contractFile) {
      md += `- **Contract file:** \`${entry.contractFile}\`\n`;
    }
    if (entry.prompt) {
      md += `- **Prompt:** ${entry.prompt}\n`;
    }
    if (entry.outputDir) {
      md += `- **Output dir:** \`${entry.outputDir}\`\n`;
    }
    if (entry.cliArgs) {
      if (typeof entry.cliArgs.maxIterations === 'number') {
        md += `- **Max iterations:** ${entry.cliArgs.maxIterations}\n`;
      }
      if (typeof entry.cliArgs.dryRun === 'boolean') {
        md += `- **Dry run:** ${entry.cliArgs.dryRun}\n`;
      }
      if (typeof entry.cliArgs.verbose === 'boolean') {
        md += `- **Verbose:** ${entry.cliArgs.verbose}\n`;
      }
    }

    if (entry.events && entry.events.length > 0) {
      md += `\n### Timeline\n\n`;
      for (const e of entry.events) {
        md += `- **${e.at}** ${e.step}${e.details ? ` â€” ${e.details}` : ''}\n`;
      }
      md += `\n`;
    }

    md += `---\n\n`;
    return md;
  }

  private buildIterationSection(entry: GenerationLogEntry): string {
    if (!entry.iterationHistory || entry.iterationHistory.length === 0) {
      return '';
    }

    let md = `## ðŸ”„ Iterations\n\n`;
    for (const h of entry.iterationHistory) {
      const files = h.filesChanged.length > 0 ? h.filesChanged.map((p) => `\`${p}\``).join(', ') : 'none';
      md += `- **#${h.iteration}**: ${h.passed ? 'passed' : 'failed'} | errors: ${h.errorCount} | warnings: ${h.warningCount} | time: ${h.timeMs}ms | files: ${files}\n`;
    }

    md += `\n---\n\n`;
    return md;
  }

  private buildNextStepsSection(entry: GenerationLogEntry): string {
    let md = `## ðŸ§© What happened next\n\n`;

    if (entry.pipelineResult.passed) {
      md += `- **Validation:** passed\n`;
      if (entry.outputDir) {
        md += `- **Next:** inspect generated code in \`${entry.outputDir}\` and run tests / start the app\n`;
      } else {
        md += `- **Next:** inspect generated code and run tests / start the app\n`;
      }
    } else {
      const failedStages = entry.pipelineResult.stages.filter((s) => !s.passed);
      md += `- **Validation:** failed\n`;
      md += `- **Failed stages:** ${failedStages.map((s) => `\`${s.stage}\``).join(', ')}\n`;
      md += `- **Next:** fix issues listed above (see Validation Details), then rerun generation/validation\n`;
    }

    md += `\n---\n\n`;
    return md;
  }

  private buildGenerationSection(generatedCode: GeneratedCode): string {
    let md = `## ðŸ“¦ ${this.L.generatedFiles}

`;

    for (const file of generatedCode.files) {
      const lang = this.getLanguageFromPath(file.path);
      md += `### \`${file.path}\`

\`\`\`${lang}
${file.content.substring(0, 500)}${file.content.length > 500 ? '\n// ... (truncated)' : ''}
\`\`\`

`;
    }

    md += `---

`;
    return md;
  }

  private buildStageIssues(stage: StageResult): string {
    let md = '';

    if (stage.errors.length > 0) {
      md += `**Errors:**\n\n`;
      for (const error of stage.errors) {
        const loc = `${error.file ? error.file : 'unknown file'}${error.line ? `:${error.line}` : ''}`;
        const code = error.code ? ` [${error.code}]` : '';
        md += `- ${loc}${code}: ${error.message}\n`;
      }
      md += `\n`;
    }

    if (stage.warnings.length > 0) {
      md += `**Warnings:**\n\n`;
      for (const warning of stage.warnings) {
        const loc = `${warning.file ? warning.file : 'unknown file'}${warning.line ? `:${warning.line}` : ''}`;
        md += `- ${loc}: ${warning.message}\n`;
      }
      md += `\n`;
    }

    return md;
  }

  private escapeTableCell(value: string): string {
    return value.replace(/\|/g, '\\|').replace(/\n/g, '<br/>');
  }

  private buildValidationSection(pipelineResult: PipelineResult): string {
    let md = `## âœ… ${this.L.validationPipeline}

| Stage | Status | Time | Errors | Warnings |
|-------|--------|------|--------|----------|
`;

    for (const stage of pipelineResult.stages) {
      const status = stage.passed ? 'âœ… PASSED' : 'âŒ FAILED';
      md += `| ${stage.stage} | ${status} | ${stage.timeMs}ms | ${stage.errors.length} | ${stage.warnings.length} |\n`;
    }

    md += `
`;

    const stagesWithIssues = pipelineResult.stages.filter(
      (s) => s.errors.length > 0 || s.warnings.length > 0
    );
    if (stagesWithIssues.length > 0) {
      md += `### Details\n\n`;
      for (const stage of stagesWithIssues) {
        md += `#### ${stage.stage}\n\n`;
        md += this.buildStageIssues(stage);
      }
      md += `\n`;
    }

    md += `---

`;
    return md;
  }

  private buildContractSection(contract: ContractAI): string {
    let md = `## ðŸ“œ ${this.L.contract}

\`\`\`typescript
// Contract AI Definition
export const contract = {
  definition: {
    app: ${JSON.stringify(contract.definition?.app || {}, null, 2).replace(/\n/g, '\n    ')},
    entities: [
${(contract.definition?.entities || []).map(e => `      "${e.name}"`).join(',\n')}
    ]
  },
  generation: {
    techStack: ${JSON.stringify(contract.generation?.techStack || {}, null, 2).replace(/\n/g, '\n    ')}
  }
};
\`\`\`

---

`;
    return md;
  }

  private buildActionsSection(entry: GenerationLogEntry, now: Date): string {
    return `## ðŸ“œ Actions

<!-- reclapp:actions -->
\`\`\`action
timestamp: ${now.toISOString()}
type: contract-ai-generation
model: ${entry.model || 'simulated'}
files: ${entry.generatedCode.files.length}
stages: ${entry.pipelineResult.stages.length}
passed: ${entry.pipelineResult.summary.passedStages}
result: ${entry.pipelineResult.passed ? 'success' : 'failed'}
\`\`\`

---

`;
  }

  private buildFooter(): string {
    return `*${this.L.generatedBy}*
`;
  }

  private generateFilename(appName: string, now: Date): string {
    const kebab = appName
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/\s+/g, '-')
      .toLowerCase();
    const timestamp = now.toISOString().replace(/[:.]/g, '-');
    return `${kebab}_${timestamp}.rcl.md`;
  }

  private getLanguageFromPath(filePath: string): string {
    if (filePath.endsWith('.ts') || filePath.endsWith('.tsx')) return 'typescript';
    if (filePath.endsWith('.js') || filePath.endsWith('.jsx')) return 'javascript';
    if (filePath.endsWith('.json')) return 'json';
    if (filePath.endsWith('.css')) return 'css';
    if (filePath.endsWith('.html')) return 'html';
    if (filePath.includes('Dockerfile')) return 'dockerfile';
    return 'text';
  }
}

// ============================================================================
// FACTORY
// ============================================================================

export function createGenerationLogWriter(options: LogWriterOptions): GenerationLogWriter {
  return new GenerationLogWriter(options);
}
