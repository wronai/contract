#!/usr/bin/env node
/**
 * Reclapp Studio Lite - Simple Web UI without Gradio
 * 
 * Express backend + vanilla HTML/JS frontend
 */

const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const http = require('http');

const app = express();
const PORT = process.env.STUDIO_LITE_PORT || 7861;
const OLLAMA_HOST = process.env.OLLAMA_HOST || 'http://localhost:11434';
const OLLAMA_MODEL = process.env.OLLAMA_MODEL || 'deepseek-coder:6.7b';

// Directories
const APPS_DIR = path.join(__dirname, '..', 'apps');
const EXAMPLES_DIR = path.join(__dirname, '..', 'examples');
const PROJECTS_DIR = path.join(__dirname, 'projects');

// Ensure directories exist
if (!fs.existsSync(PROJECTS_DIR)) fs.mkdirSync(PROJECTS_DIR, { recursive: true });

app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// System prompt for contract generation
const SYSTEM_PROMPT = `You are a contract designer for Reclapp. Generate application contracts in Reclapp Mini-DSL (RCL) format.

OUTPUT FORMAT: Always respond with JSON:
\`\`\`json
{
  "thinking": "Your analysis",
  "contract": "RCL code (MUST be a single string; use \\n for newlines; do not return an object/array)",
  "summary": {"entities": [], "events": [], "features": []}
}
\`\`\`

RCL SYNTAX:
- app "Name" { version: "1.0.0" }
- entity Name { field type @modifiers }
- enum Name { Value1, Value2 }
- event Name { field: type }
- alert "Name" { entity: E, when: condition, notify: [email], severity: high }

Types: text, email, int, float, bool, date, datetime, uuid, money(PLN)
Modifiers: @unique, @required, @generated, @index
Relations: -> Entity (belongs_to), <- Entity[] (has_many)`;

// API Routes

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', model: OLLAMA_MODEL, ollama: OLLAMA_HOST });
});

// Session logging
const LOGS_DIR = path.join(PROJECTS_DIR, 'logs');
if (!fs.existsSync(LOGS_DIR)) fs.mkdirSync(LOGS_DIR, { recursive: true });

function saveSessionLog(history, contract, projectName = 'session') {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const logPath = path.join(LOGS_DIR, `${projectName}_${timestamp}.rcl.md`);
  
  // Extract app name from contract
  const appMatch = contract ? contract.match(/app\s+["']([^"']+)["']/) : null;
  const appName = appMatch ? appMatch[1] : projectName;
  
  // Count entities/events/enums
  const entities = contract ? (contract.match(/entity\s+\w+/g) || []).length : 0;
  const events = contract ? (contract.match(/event\s+\w+/g) || []).length : 0;
  const enums = contract ? (contract.match(/enum\s+\w+/g) || []).length : 0;
  
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0];
  const timeStr = now.toTimeString().split(' ')[0];
  
  const lines = [
    `# ${appName}`,
    ``,
    `> Generated by Reclapp Studio Lite`,
    ``,
    `## Metadata`,
    ``,
    `| Property | Value |`,
    `|----------|-------|`,
    `| Project | ${projectName} |`,
    `| Created | ${dateStr} |`,
    `| Time | ${timeStr} |`,
    `| Messages | ${history.length} |`,
    `| Model | ${OLLAMA_MODEL} |`,
    `| Entities | ${entities} |`,
    `| Events | ${events} |`,
    `| Enums | ${enums} |`,
    ``,
    `---`,
    ``,
    `## ğŸ’¬ Conversation`,
    ``,
    `<!-- reclapp:conversation -->`,
    ``
  ];
  
  history.forEach((msg, i) => {
    const role = msg.role === 'user' ? 'ğŸ§‘ User' : 'ğŸ¤– Assistant';
    const msgTime = `${dateStr} ${timeStr}`;
    lines.push(`### ${role} (${msgTime})`);
    lines.push(``);
    lines.push(msg.content || '');
    lines.push(``);
  });
  
  lines.push(`---`);
  lines.push(``);
  
  if (contract) {
    lines.push(`## ğŸ“¦ Contract (RCL)`);
    lines.push(``);
    lines.push('```rcl');
    lines.push(contract);
    lines.push('```');
    lines.push(``);
    lines.push(`---`);
    lines.push(``);
  }
  
  lines.push(`## ğŸ“œ Actions`);
  lines.push(``);
  lines.push(`<!-- reclapp:actions -->`);
  lines.push('```action');
  lines.push(`timestamp: ${now.toISOString()}`);
  lines.push(`type: chat`);
  lines.push(`model: ${OLLAMA_MODEL}`);
  lines.push(`messages: ${history.length}`);
  lines.push(`result: success`);
  lines.push('```');
  lines.push(``);
  lines.push(`---`);
  lines.push(``);
  lines.push(`*Generated by Reclapp Studio Lite*`);
  
  fs.writeFileSync(logPath, lines.join('\n'));
  return logPath;
}

// Auto-validation with retry
const MAX_RETRIES = 2;

function validateContractSyntax(contract) {
  if (!contract) return { valid: false, errors: ['No contract extracted'] };
  
  const errors = [];
  
  // Check app declaration
  if (!contract.match(/app\s+["']/)) {
    errors.push('Missing app declaration');
  }
  
  // Check balanced braces
  const openBraces = (contract.match(/\{/g) || []).length;
  const closeBraces = (contract.match(/\}/g) || []).length;
  if (openBraces !== closeBraces) {
    errors.push(`Unbalanced braces: ${openBraces} open, ${closeBraces} close`);
  }
  
  // Check for TypeScript syntax mistakes
  if (/:\s*string\b/i.test(contract)) {
    errors.push("Use 'text' instead of 'string'");
  }
  if (/:\s*number\b/i.test(contract)) {
    errors.push("Use 'int', 'float', or 'decimal' instead of 'number'");
  }
  
  // Check for missing required sections
  if (!contract.match(/entity\s+\w+/)) {
    errors.push('No entities defined');
  }
  
  return { valid: errors.length === 0, errors };
}

function buildFixPrompt(contract, errors) {
  return `The contract has errors. Please fix them and return ONLY the corrected contract in JSON format.

ERRORS:
${errors.map(e => `- ${e}`).join('\n')}

ORIGINAL CONTRACT:
${contract}

Return ONLY valid JSON with the fixed contract:
\`\`\`json
{
  "thinking": "describe fixes",
  "contract": "fixed RCL code here",
  "summary": {"entities": [], "events": []}
}
\`\`\``;
}

// Chat with LLM (with auto-validation and retry)
app.post('/api/chat', async (req, res) => {
  const { message, history = [], projectName = 'session' } = req.body;
  
  const messages = [
    { role: 'system', content: SYSTEM_PROMPT },
    ...history,
    { role: 'user', content: message }
  ];

  try {
    let response = await callOllama(messages);
    let contract = extractContract(response);
    let validation = validateContractSyntax(contract);
    let retries = 0;
    const fixes = [];
    
    // Auto-fix loop
    while (!validation.valid && contract && retries < MAX_RETRIES) {
      retries++;
      fixes.push({ attempt: retries, errors: validation.errors });
      
      // Ask LLM to fix errors
      const fixPrompt = buildFixPrompt(contract, validation.errors);
      const fixMessages = [
        { role: 'system', content: SYSTEM_PROMPT },
        { role: 'user', content: fixPrompt }
      ];
      
      const fixResponse = await callOllama(fixMessages);
      const fixedContract = extractContract(fixResponse);
      
      if (fixedContract) {
        contract = fixedContract;
        validation = validateContractSyntax(contract);
        response += `\n\n---\nğŸ”§ Auto-fix attempt ${retries}:\n${fixResponse}`;
      } else {
        break;
      }
    }
    
    // Save session log in .rcl.md format
    const updatedHistory = [...history, { role: 'user', content: message }, { role: 'assistant', content: response }];
    const logPath = saveSessionLog(updatedHistory, contract, projectName);
    
    res.json({
      success: true,
      response,
      contract,
      validation,
      fixes,
      model: OLLAMA_MODEL,
      logPath
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// List projects
app.get('/api/projects', (req, res) => {
  const projects = scanProjects();
  res.json({ success: true, projects });
});

// Get project contract
app.get('/api/projects/:source/:name/contract', (req, res) => {
  const { source, name } = req.params;
  const format = req.query.format || 'rcl';
  
  const baseDir = source === 'apps' ? APPS_DIR : EXAMPLES_DIR;
  const contractsDir = path.join(baseDir, name, 'contracts');
  
  if (!fs.existsSync(contractsDir)) {
    return res.json({ success: false, error: 'Contracts directory not found' });
  }
  
  // Find contract file by format
  const files = fs.readdirSync(contractsDir);
  let contractFile = null;
  
  for (const f of files) {
    if (format === 'md' && (f.endsWith('.rcl.md') || f.endsWith('.md'))) {
      contractFile = path.join(contractsDir, f);
      break;
    } else if (format === 'rcl' && f.endsWith('.reclapp.rcl')) {
      contractFile = path.join(contractsDir, f);
      break;
    } else if (format === 'ts' && f.endsWith('.reclapp.ts')) {
      contractFile = path.join(contractsDir, f);
      break;
    }
  }
  
  // Fallback
  if (!contractFile) {
    for (const f of files) {
      if (f.includes('.rcl') || f.includes('.ts') || f.endsWith('.md')) {
        contractFile = path.join(contractsDir, f);
        break;
      }
    }
  }
  
  if (!contractFile) {
    return res.json({ success: false, error: 'No contract file found' });
  }
  
  const content = fs.readFileSync(contractFile, 'utf-8');
  res.json({ success: true, content, file: path.basename(contractFile) });
});

// Validate contract
app.post('/api/validate', (req, res) => {
  const { contract } = req.body;
  const result = validateContract(contract);
  res.json(result);
});

// Save contract
app.post('/api/save', (req, res) => {
  const { name, contract, format = 'rcl', history = [] } = req.body;
  
  try {
    const projectDir = path.join(PROJECTS_DIR, name, 'contracts');
    fs.mkdirSync(projectDir, { recursive: true });
    
    let filename, content;
    const savedFiles = [];
    
    // Extract app name from contract
    const appMatch = contract.match(/app\s+["']([^"']+)["']/);
    const appName = appMatch ? appMatch[1] : name;
    
    // Count entities/events/enums
    const entities = (contract.match(/entity\s+\w+/g) || []).length;
    const events = (contract.match(/event\s+\w+/g) || []).length;
    const enums = (contract.match(/enum\s+\w+/g) || []).length;
    
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    const timeStr = now.toTimeString().split(' ')[0];
    
    if (format === 'md' || format === 'all') {
      filename = 'main.rcl.md';
      
      // Build markdown with conversation
      let mdContent = `# ${appName}\n\n`;
      mdContent += `> Generated by Reclapp Studio Lite\n\n`;
      mdContent += `## Metadata\n\n`;
      mdContent += `| Property | Value |\n`;
      mdContent += `|----------|-------|\n`;
      mdContent += `| Project | ${name} |\n`;
      mdContent += `| Created | ${dateStr} |\n`;
      mdContent += `| Time | ${timeStr} |\n`;
      mdContent += `| Entities | ${entities} |\n`;
      mdContent += `| Events | ${events} |\n`;
      mdContent += `| Enums | ${enums} |\n\n`;
      mdContent += `---\n\n`;
      
      // Add conversation if present
      if (history && history.length > 0) {
        mdContent += `## ğŸ’¬ Conversation\n\n`;
        mdContent += `<!-- reclapp:conversation -->\n\n`;
        
        history.forEach((msg, i) => {
          const role = msg.role === 'user' ? 'ğŸ§‘ User' : 'ğŸ¤– Assistant';
          mdContent += `### ${role}\n\n`;
          mdContent += `${msg.content}\n\n`;
        });
        
        mdContent += `---\n\n`;
      }
      
      mdContent += `## ğŸ“¦ Contract (RCL)\n\n`;
      mdContent += `\`\`\`rcl\n${contract}\n\`\`\`\n\n`;
      mdContent += `---\n\n`;
      mdContent += `*Generated by Reclapp Studio Lite*\n`;
      
      const mdPath = path.join(projectDir, filename);
      fs.writeFileSync(mdPath, mdContent);
      savedFiles.push({ name: filename, path: mdPath, ext: 'md' });
    }
    
    if (format === 'rcl' || format === 'all') {
      filename = 'main.reclapp.rcl';
      const rclPath = path.join(projectDir, filename);
      fs.writeFileSync(rclPath, contract);
      savedFiles.push({ name: filename, path: rclPath, ext: 'rcl' });
    }
    
    if (format === 'ts' || format === 'all') {
      filename = 'main.reclapp.ts';
      const tsContent = generateTypeScriptFromRCL(contract);
      const tsPath = path.join(projectDir, filename);
      fs.writeFileSync(tsPath, tsContent);
      savedFiles.push({ name: filename, path: tsPath, ext: 'ts' });
    }
    
    res.json({ 
      success: true, 
      path: savedFiles[0]?.path || projectDir,
      files: savedFiles.map(f => ({ name: f.name, path: `projects/${name}/contracts/`, ext: f.ext }))
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Generate project (calls reclapp CLI)
app.post('/api/generate', (req, res) => {
  const { source, name } = req.body;
  
  const baseDir = source === 'apps' ? APPS_DIR : (source === 'examples' ? EXAMPLES_DIR : PROJECTS_DIR);
  const projectDir = path.join(baseDir, name);
  const contractsDir = path.join(projectDir, 'contracts');
  
  // Find contract file
  if (!fs.existsSync(contractsDir)) {
    return res.json({ success: false, error: 'No contracts directory' });
  }
  
  const files = fs.readdirSync(contractsDir);
  let contractFile = files.find(f => f.endsWith('.reclapp.rcl') || f.endsWith('.reclapp.ts'));
  
  if (!contractFile) {
    return res.json({ success: false, error: 'No .rcl or .ts contract found' });
  }
  
  const contractPath = path.join(contractsDir, contractFile);
  const targetDir = path.join(projectDir, 'target');
  
  // Return command to run (we don't execute it directly for safety)
  res.json({
    success: true,
    command: `./bin/reclapp generate ${contractPath} -o ${targetDir}`,
    contractPath,
    targetDir
  });
});

// Auto-generate formats from existing contract
app.post('/api/auto-generate', (req, res) => {
  const { source, name } = req.body;
  
  const baseDir = source === 'apps' ? APPS_DIR : (source === 'examples' ? EXAMPLES_DIR : PROJECTS_DIR);
  const projectDir = path.join(baseDir, name);
  const contractsDir = path.join(projectDir, 'contracts');
  
  if (!fs.existsSync(contractsDir)) {
    return res.json({ success: false, error: 'No contracts directory' });
  }
  
  const files = fs.readdirSync(contractsDir);
  const generated = [];
  
  // Find existing contract
  let rclContent = null;
  let rclFile = files.find(f => f.endsWith('.reclapp.rcl'));
  let mdFile = files.find(f => f.endsWith('.rcl.md') || f.endsWith('.md'));
  let tsFile = files.find(f => f.endsWith('.reclapp.ts'));
  
  // Read RCL if exists
  if (rclFile) {
    rclContent = fs.readFileSync(path.join(contractsDir, rclFile), 'utf-8');
  } else if (mdFile) {
    // Extract RCL from markdown
    const mdContent = fs.readFileSync(path.join(contractsDir, mdFile), 'utf-8');
    const rclMatch = mdContent.match(/```rcl\s*([\s\S]*?)\s*```/);
    if (rclMatch) {
      rclContent = rclMatch[1];
      // Save as .rcl
      const newRclFile = mdFile.replace('.rcl.md', '.reclapp.rcl').replace('.md', '.reclapp.rcl');
      fs.writeFileSync(path.join(contractsDir, newRclFile), rclContent);
      generated.push(newRclFile);
    }
  }
  
  if (!rclContent) {
    return res.json({ success: false, error: 'No contract content found' });
  }
  
  // Generate missing formats
  if (!mdFile) {
    const appMatch = rclContent.match(/app\s+["']([^"']+)["']/);
    const appName = appMatch ? appMatch[1] : name;
    const mdContent = `# ${appName}\n\n> Generated by Reclapp Studio\n\n## Contract\n\n\`\`\`rcl\n${rclContent}\n\`\`\`\n`;
    fs.writeFileSync(path.join(contractsDir, 'main.rcl.md'), mdContent);
    generated.push('main.rcl.md');
  }
  
  if (!tsFile) {
    const tsContent = generateTypeScriptFromRCL(rclContent);
    fs.writeFileSync(path.join(contractsDir, 'main.reclapp.ts'), tsContent);
    generated.push('main.reclapp.ts');
  }
  
  res.json({ 
    success: true, 
    generated,
    message: generated.length > 0 ? `Generated ${generated.length} files` : 'All formats already exist'
  });
});

// Helper to generate TypeScript
function generateTypeScriptFromRCL(rcl) {
  const appMatch = rcl.match(/app\s+["']([^"']+)["']/);
  const appName = appMatch ? appMatch[1] : 'App';
  
  let ts = `/**
 * ${appName} - Reclapp Contract
 * Generated: ${new Date().toISOString()}
 */

import type { ReclappContract, Entity } from '@reclapp/contracts';

`;

  const entityRegex = /entity\s+(\w+)\s*\{([^}]*)\}/g;
  let match;
  const entities = [];
  
  while ((match = entityRegex.exec(rcl)) !== null) {
    const [, eName, body] = match;
    entities.push(eName);
    ts += `export interface ${eName} {\n`;
    const lines = body.split('\n').map(l => l.trim()).filter(Boolean);
    for (const line of lines) {
      const fieldMatch = line.match(/^(\w+)\s+(\w+)/);
      if (fieldMatch) {
        const typeMap = { uuid: 'string', text: 'string', email: 'string', int: 'number', float: 'number', bool: 'boolean', date: 'Date', datetime: 'Date', decimal: 'number' };
        ts += `  ${fieldMatch[1]}: ${typeMap[fieldMatch[2]] || fieldMatch[2]};\n`;
      }
    }
    ts += `}\n\n`;
  }
  
  ts += `export const contract: ReclappContract = {
  app: { name: '${appName}', version: '1.0.0' },
  entities: [${entities.map(e => `'${e}'`).join(', ')}]
};

export default contract;
`;
  return ts;
}

// Run project - generate and start servers
app.post('/api/run', (req, res) => {
  const { source, name, action = 'start', autoGenerate = true, contract = null } = req.body;
  const { execSync, spawn } = require('child_process');
  
  const baseDir = source === 'apps' ? APPS_DIR : (source === 'examples' ? EXAMPLES_DIR : PROJECTS_DIR);
  const projectDir = path.join(baseDir, name);
  const targetDir = path.join(projectDir, 'target');
  const contractsDir = path.join(projectDir, 'contracts');
  
  try {
    // Create contracts dir if doesn't exist
    if (!fs.existsSync(contractsDir)) {
      fs.mkdirSync(contractsDir, { recursive: true });
    }
    
    // Save contract if provided
    if (contract) {
      const rclPath = path.join(contractsDir, 'main.reclapp.rcl');
      fs.writeFileSync(rclPath, contract);
      console.log(`Saved contract to ${rclPath}`);
    }
    
    // Auto-generate formats
    const files = fs.readdirSync(contractsDir);
    let rclFile = files.find(f => f.endsWith('.reclapp.rcl'));
    
    if (!rclFile) {
      // Try to extract from .md
      const mdFile = files.find(f => f.endsWith('.rcl.md') || f.endsWith('.md'));
      if (mdFile) {
        const mdContent = fs.readFileSync(path.join(contractsDir, mdFile), 'utf-8');
        const rclMatch = mdContent.match(/```rcl\s*([\s\S]*?)\s*```/);
        if (rclMatch) {
          fs.writeFileSync(path.join(contractsDir, 'main.reclapp.rcl'), rclMatch[1]);
          rclFile = 'main.reclapp.rcl';
        }
      }
    }
    
    if (!rclFile) {
      return res.json({
        success: false,
        error: 'No contract file found. Save the contract first.',
        needsSave: true
      });
    }
    
    const contractPath = path.join(contractsDir, rclFile);
    const generateCmd = `./bin/reclapp generate ${contractPath} -o ${targetDir}`;
    
    // Check if target exists, if not - try to generate
    if (!fs.existsSync(targetDir)) {
      return res.json({ 
        success: false, 
        error: 'Target not built.',
        needsGenerate: true,
        generateCommand: generateCmd,
        contractPath,
        targetDir
      });
    }
    
    const apiDir = path.join(targetDir, 'api');
    const frontendDir = path.join(targetDir, 'frontend');
    
    // Find available ports
    const apiPort = 8080 + Math.floor(Math.random() * 100);
    const frontendPort = 3000 + Math.floor(Math.random() * 100);
    
    const urls = {
      api: null,
      frontend: null,
      dashboard: null
    };
    
    // Start API if exists
    if (fs.existsSync(apiDir) && fs.existsSync(path.join(apiDir, 'package.json'))) {
      urls.api = `http://localhost:${apiPort}`;
    }
    
    // Start Frontend if exists
    if (fs.existsSync(frontendDir) && fs.existsSync(path.join(frontendDir, 'package.json'))) {
      urls.frontend = `http://localhost:${frontendPort}`;
    }
    
    // Dashboard URL
    urls.dashboard = `http://localhost:${frontendPort}`;
    
    // Generate run script
    const runScript = `#!/bin/bash
# Auto-generated run script for ${name}
cd "${targetDir}"

# Start API
if [ -d "api" ]; then
  cd api && npm install --silent && PORT=${apiPort} npm run dev &
  API_PID=$!
  cd ..
fi

# Start Frontend  
if [ -d "frontend" ]; then
  cd frontend && npm install --silent && PORT=${frontendPort} npm run dev &
  FRONTEND_PID=$!
  cd ..
fi

echo "ğŸš€ ${name} running:"
echo "   API: ${urls.api || 'N/A'}"
echo "   Frontend: ${urls.frontend || 'N/A'}"
echo ""
echo "Press Ctrl+C to stop"

wait
`;
    
    const scriptPath = path.join(targetDir, 'run.sh');
    fs.writeFileSync(scriptPath, runScript);
    fs.chmodSync(scriptPath, '755');
    
    res.json({
      success: true,
      message: `Project ${name} ready to run`,
      urls,
      runScript: scriptPath,
      command: `bash ${scriptPath}`,
      // URI scheme for desktop integration
      uri: `reclapp://${name}?api=${apiPort}&frontend=${frontendPort}`
    });
    
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Open in browser/system
app.post('/api/open', (req, res) => {
  const { url } = req.body;
  const { exec } = require('child_process');
  
  // Detect OS and open URL
  const platform = process.platform;
  let cmd;
  
  if (platform === 'linux') {
    cmd = `xdg-open "${url}"`;
  } else if (platform === 'darwin') {
    cmd = `open "${url}"`;
  } else if (platform === 'win32') {
    cmd = `start "" "${url}"`;
  }
  
  if (cmd) {
    exec(cmd, (error) => {
      if (error) {
        res.json({ success: false, error: error.message });
      } else {
        res.json({ success: true, message: `Opened ${url}` });
      }
    });
  } else {
    res.json({ success: false, error: 'Unsupported platform' });
  }
});

// Helper functions

function callOllama(messages) {
  return new Promise((resolve, reject) => {
    const url = new URL(OLLAMA_HOST);
    const postData = JSON.stringify({
      model: OLLAMA_MODEL,
      messages,
      stream: false,
      options: { temperature: 0.7 }
    });

    const options = {
      hostname: url.hostname,
      port: url.port || 11434,
      path: '/api/chat',
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(postData)
      }
    };

    const req = http.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          const json = JSON.parse(data);
          resolve(json.message?.content || 'No response');
        } catch (e) {
          reject(new Error('Failed to parse Ollama response'));
        }
      });
    });

    req.on('error', reject);
    req.setTimeout(120000, () => reject(new Error('Request timeout')));
    req.write(postData);
    req.end();
  });
}

function coerceToRclString(value) {
  if (typeof value === 'string') {
    return value.replace(/\\n/g, '\n').replace(/\\"/g, '"');
  }
  if (!value || typeof value !== 'object') return null;
  if (typeof value.rcl === 'string') return coerceToRclString(value.rcl);
  if (typeof value.source === 'string') return coerceToRclString(value.source);
  if (typeof value.text === 'string') return coerceToRclString(value.text);
  return null;
}

function isLikelyRcl(contract) {
  const s = String(contract || '').trim();
  if (!s) return false;
  if (s.startsWith('{') || s.startsWith('[')) return false;
  if (/^\s*"contract"\s*:/m.test(s)) return false;
  return /^(app|entity|enum|event|alert|dashboard|pipeline|source|config)\b/m.test(s);
}

function convertLegacyJsonContractToRcl(obj) {
  if (!obj || typeof obj !== 'object') return null;

  const enums = new Map();
  const entities = [];
  const events = [];
  const other = [];

  const addEnum = (name, values) => {
    const enumName = String(name || '').trim();
    if (!enumName) return;
    const vals = Array.isArray(values)
      ? values.map(v => String(v).trim()).filter(Boolean)
      : String(values || '')
          .split(',')
          .map(v => v.trim())
          .filter(Boolean);
    if (!vals.length) return;
    if (!enums.has(enumName)) {
      enums.set(enumName, `enum ${enumName} { ${vals.join(', ')} }`);
    }
  };

  const appStr = typeof obj.app === 'string' ? obj.app.trim() : '';
  if (appStr) {
    const m = appStr.match(/^\s*([^{}]+?)\s*\{\s*version\s*:\s*['"]([^'"]+)['"][^}]*\}\s*$/);
    if (m) {
      other.push(`app "${m[1].trim()}" { version: "${m[2].trim()}" }`);
    } else if (/^\s*app\b/.test(appStr)) {
      other.push(appStr);
    }
  }

  const asList = v => (Array.isArray(v) ? v : []);
  const entityBlocks = asList(obj.entities).length ? obj.entities : obj.entity;
  for (const raw of asList(entityBlocks)) {
    const s = String(raw || '').trim();
    if (!s) continue;

    const enumLike = s.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*\{\s*([^:{}@]+?)\s*\}\s*$/);
    if (enumLike && enumLike[2].includes(',')) {
      addEnum(enumLike[1], enumLike[2]);
      continue;
    }

    const m = s.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*\{([\s\S]*)\}\s*$/);
    if (!m) continue;

    const name = m[1];
    let body = m[2].trim();
    body = body.replace(/,\s*/g, '\n');
    const lines = body
      .split('\n')
      .map(l => l.trim())
      .filter(Boolean)
      .map(l => l.replace(/:\s*/g, ' '))
      .map(l => {
        const em = l.match(/^([A-Za-z_][A-Za-z0-9_]*)\s+enum\s+([A-Za-z_][A-Za-z0-9_]*)\s*\{\s*([^}]+)\s*\}\s*$/);
        if (em) {
          addEnum(em[2], em[3]);
          return `${em[1]} ${em[2]}`;
        }
        return l;
      });

    entities.push(`entity ${name} {\n${lines.map(l => `  ${l}`).join('\n')}\n}`);
  }

  const eventBlocks = asList(obj.events).length ? obj.events : obj.event;
  for (const raw of asList(eventBlocks)) {
    const s = String(raw || '').trim();
    if (!s) continue;
    const m = s.match(/^\s*([A-Za-z_][A-Za-z0-9_]*)\s*\{([\s\S]*)\}\s*$/);
    if (!m) continue;
    const name = m[1];
    let body = m[2].trim();
    body = body.replace(/,\s*/g, '\n');
    const lines = body
      .split('\n')
      .map(l => l.trim())
      .filter(Boolean);
    events.push(`event ${name} {\n${lines.map(l => `  ${l}`).join('\n')}\n}`);
  }

  const parts = [];
  parts.push(...other);
  parts.push(...Array.from(enums.values()));
  parts.push(...entities);
  parts.push(...events);

  const out = parts.join('\n\n').trim();
  return out || null;
}

function extractContract(response) {
  // Try JSON extraction
  const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
  if (jsonMatch) {
    try {
      const parsed = JSON.parse(jsonMatch[1]);
      if (parsed && parsed.contract !== undefined) {
        const contractStr = coerceToRclString(parsed.contract) || convertLegacyJsonContractToRcl(parsed.contract);
        if (contractStr && isLikelyRcl(contractStr)) {
          return contractStr;
        }
      }
    } catch (e) {}
  }

  // Fallback: extract RCL directly
  const lines = [];
  let inBlock = false;
  let blockLang = '';
  for (const line of response.split('\n')) {
    const trimmed = line.trim();
    if (trimmed.startsWith('```')) {
      inBlock = !inBlock;
      if (inBlock) {
        const m = trimmed.match(/^```\s*([A-Za-z0-9_-]+)?/);
        blockLang = (m && m[1] ? m[1] : '').toLowerCase();
      } else {
        blockLang = '';
      }
      continue;
    }
    if ((inBlock && (!blockLang || blockLang === 'rcl')) || /^(app|entity|enum|event|alert|dashboard|pipeline)\s/.test(trimmed)) {
      lines.push(line);
    } else if (lines.length && (trimmed.startsWith('{') || trimmed.startsWith('}') || trimmed.includes(':'))) {
      lines.push(line);
    }
  }
  const candidate = lines.join('\n').trim() || null;
  return candidate && isLikelyRcl(candidate) ? candidate : null;
}

function validateContract(contract) {
  const errors = [];
  const warnings = [];
  
  // Check app declaration
  if (!contract.match(/app\s+["']/)) {
    errors.push('Missing app declaration');
  }
  
  // Check balanced braces
  const openBraces = (contract.match(/\{/g) || []).length;
  const closeBraces = (contract.match(/\}/g) || []).length;
  if (openBraces !== closeBraces) {
    errors.push(`Unbalanced braces: ${openBraces} open, ${closeBraces} close`);
  }
  
  // Check for TypeScript syntax mistakes
  if (/:\s*string\b/i.test(contract)) {
    errors.push("Invalid type 'string'. Use 'text' instead.");
  }
  if (/:\s*number\b/i.test(contract)) {
    errors.push("Invalid type 'number'. Use 'int', 'float', or 'decimal'.");
  }
  
  // Count elements
  const entities = (contract.match(/entity\s+\w+/g) || []).length;
  const events = (contract.match(/event\s+\w+/g) || []).length;
  const enums = (contract.match(/enum\s+\w+/g) || []).length;
  
  return {
    valid: errors.length === 0,
    errors,
    warnings,
    stats: { entities, events, enums }
  };
}

function scanProjects() {
  const projects = [];
  
  for (const [dir, source] of [[APPS_DIR, 'apps'], [EXAMPLES_DIR, 'examples']]) {
    if (!fs.existsSync(dir)) continue;
    
    for (const name of fs.readdirSync(dir)) {
      const projectDir = path.join(dir, name);
      if (!fs.statSync(projectDir).isDirectory()) continue;
      
      const contractsDir = path.join(projectDir, 'contracts');
      const targetDir = path.join(projectDir, 'target');
      
      if (!fs.existsSync(contractsDir)) continue;
      
      const files = fs.readdirSync(contractsDir);
      const formats = {
        md: files.some(f => f.endsWith('.rcl.md') || f.endsWith('.md')),
        rcl: files.some(f => f.endsWith('.reclapp.rcl')),
        ts: files.some(f => f.endsWith('.reclapp.ts'))
      };
      
      const hasTarget = fs.existsSync(targetDir) && fs.readdirSync(targetDir).length > 0;
      
      projects.push({
        name,
        source,
        path: projectDir,
        formats,
        hasTarget,
        status: hasTarget ? 'built' : 'not_built'
      });
    }
  }
  
  return projects;
}

// Start server
app.listen(PORT, () => {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ğŸš€ RECLAPP STUDIO LITE                             â•‘
â•‘           Simple Web UI (no Gradio)                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŒ Web UI:    http://localhost:${PORT}
ğŸ¤– LLM:       ${OLLAMA_MODEL} @ ${OLLAMA_HOST}
ğŸ“ Projects:  ${PROJECTS_DIR}

API Endpoints:
  GET  /api/health              - Health check
  POST /api/chat                - Chat with LLM
  GET  /api/projects            - List projects
  GET  /api/projects/:s/:n/contract - Get contract
  POST /api/validate            - Validate contract
  POST /api/save                - Save contract
  POST /api/generate            - Generate project
`);
});
