/**
 * Simple Generator - Contract to Application Generator
 * 
 * Generates full-stack applications from ReclappContract definitions.
 */

import * as path from 'path';
import * as fs from 'fs';
import type { ReclappContract } from '../../contracts/dsl-types';
import * as templates from '../templates';

export interface GeneratedFile {
  path: string;
  content: string;
}

export class SimpleGenerator {
  private contract: ReclappContract;
  private outputDir: string;
  private files: GeneratedFile[] = [];

  constructor(contract: ReclappContract, outputDir: string) {
    this.contract = contract;
    this.outputDir = outputDir;
  }

  generate(): GeneratedFile[] {
    console.log(`\nðŸš€ Generating ${this.contract.app.name} v${this.contract.app.version}...`);
    console.log(`ðŸ“ Output: ${this.outputDir}\n`);

    this.generateApi();
    this.generateFrontend();
    this.generateDatabase();
    this.generateDocker();
    this.generateProjectFiles();

    return this.files;
  }

  private addFile(relativePath: string, content: string): void {
    this.files.push({
      path: path.join(this.outputDir, relativePath),
      content
    });
  }

  private generateApi(): void {
    const entities = this.contract.entities || [];
    const ctx: templates.TemplateContext = {
      appName: this.contract.app.name,
      appVersion: this.contract.app.version,
      entities: entities.map(e => ({
        name: e.name,
        fields: e.fields || []
      }))
    };

    // Server
    this.addFile('api/src/server.ts', templates.serverTemplate(ctx));

    // Routes and Models
    for (const entity of entities) {
      const kebabName = templates.kebab(entity.name);
      this.addFile(`api/src/routes/${kebabName}.ts`, templates.routeTemplate(entity.name, entity.fields || []));
      this.addFile(`api/src/models/${kebabName}.ts`, templates.modelTemplate(entity.name, entity.fields || []));
    }

    // Package files
    this.addFile('api/package.json', templates.apiPackageJson(this.contract.app.name, this.contract.app.version));
    this.addFile('api/tsconfig.json', templates.apiTsConfig());
  }

  private generateFrontend(): void {
    const entities = this.contract.entities || [];
    const ctx: templates.FrontendContext = {
      appName: this.contract.app.name,
      appVersion: this.contract.app.version,
      entities: entities.map(e => ({
        name: e.name,
        fields: e.fields || []
      }))
    };

    // Main app files
    this.addFile('frontend/src/App.tsx', templates.appTemplate(ctx));
    this.addFile('frontend/src/main.tsx', templates.mainTemplate());
    this.addFile('frontend/src/index.css', templates.indexCss());

    // Components
    for (const entity of entities) {
      this.addFile(
        `frontend/src/components/${entity.name}List.tsx`,
        templates.componentTemplate(entity.name, entity.fields || [])
      );
    }

    // Hooks
    this.addFile('frontend/src/hooks/useApi.ts', templates.hooksTemplate(entities));

    // Config files
    this.addFile('frontend/package.json', templates.frontendPackageJson(this.contract.app.name, this.contract.app.version));
    this.addFile('frontend/vite.config.ts', templates.viteConfig());
    this.addFile('frontend/index.html', templates.indexHtml(this.contract.app.name));
    this.addFile('frontend/tailwind.config.js', templates.tailwindConfig());
    this.addFile('frontend/postcss.config.js', templates.postcssConfig());
    this.addFile('frontend/tsconfig.json', templates.frontendTsConfig());
  }

  private generateDatabase(): void {
    const entities = this.contract.entities || [];
    this.addFile(
      'database/migrations/001_init.sql',
      templates.sqlMigration(this.contract.app.name, entities.map(e => ({
        name: e.name,
        fields: e.fields || []
      })))
    );
  }

  private generateDocker(): void {
    this.addFile('docker/Dockerfile.api', templates.apiDockerfile());
    this.addFile('docker/Dockerfile.frontend', templates.frontendDockerfile());
    this.addFile('frontend/nginx.conf', templates.nginxConfig());
    this.addFile('docker-compose.yml', templates.dockerCompose(this.contract.app.name));
  }

  private generateProjectFiles(): void {
    this.addFile('README.md', this.readmeTemplate());
    this.addFile('.env.example', templates.envExample(this.contract.app.name));
    this.addFile('.gitignore', templates.gitignore());
  }

  private readmeTemplate(): string {
    return `# ${this.contract.app.name}

${this.contract.app.description || ''}

## Quick Start

\`\`\`bash
cd api && npm install && npm run dev
cd frontend && npm install && npm run dev
\`\`\`

## Docker

\`\`\`bash
docker-compose up -d
\`\`\`

## API Endpoints

${(this.contract.entities || []).map(e => `- \`/api/${templates.kebab(e.name)}s\` - ${e.name} CRUD`).join('\n')}

## Generated by Reclapp

This application was generated from a \`.reclapp.ts\` contract.
`;
  }

  /**
   * Write all generated files to disk
   */
  writeFiles(verbose: boolean = false): number {
    let written = 0;
    for (const file of this.files) {
      const dir = path.dirname(file.path);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(file.path, file.content, 'utf-8');
      if (verbose) {
        const rel = path.relative(this.outputDir, file.path);
        console.log(`  âœ“ ${rel}`);
      }
      written++;
    }
    return written;
  }
}

/**
 * Generate from contract - convenience function
 */
export async function generateFromContract(
  contract: ReclappContract,
  outputDir: string,
  options: { verbose?: boolean } = {}
): Promise<number> {
  const generator = new SimpleGenerator(contract, outputDir);
  generator.generate();
  return generator.writeFiles(options.verbose);
}
