#!/usr/bin/env node
/**
 * Reclapp Studio - Simple Web UI
 * 
 * Express backend + vanilla HTML/JS frontend
 */

const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const http = require('http');
const net = require('net');

const app = express();
const PORT = process.env.STUDIO_PORT || 7861;
const OLLAMA_HOST = process.env.OLLAMA_HOST || 'http://localhost:11434';
const OLLAMA_MODEL = process.env.OLLAMA_MODEL || 'deepseek-coder:6.7b';

// Directories
const APPS_DIR = path.join(__dirname, '..', 'apps');
const EXAMPLES_DIR = path.join(__dirname, '..', 'examples');
const PROJECTS_DIR = path.join(__dirname, 'projects');

const runningProjects = new Map();

// Ensure directories exist
if (!fs.existsSync(PROJECTS_DIR)) fs.mkdirSync(PROJECTS_DIR, { recursive: true });

app.use(cors());
app.use(express.json());
app.use(express.static(path.join(__dirname, 'public')));

// System prompt for contract generation
const SYSTEM_PROMPT = `You are a contract designer for Reclapp. Generate application contracts in Reclapp Mini-DSL (RCL) format.

## OUTPUT FORMAT
Respond with ONLY valid RCL code inside a \`\`\`rcl code block.

\`\`\`rcl
app "AppName" {
  version: "1.0.0"
}

entity EntityName {
  id uuid @unique @generated
  name text @required
  owner -> User?
}
\`\`\`

## RULES (IMPORTANT)
- In entity fields, DO NOT use ':' and DO NOT use commas.
  âœ… name text @required
  âŒ name: text @required,
- Relations use arrows BEFORE the target:
  âœ… owner -> User?
  âœ… items <- Item[]
- money type must use parentheses:
  âœ… price money(PLN)
  âŒ price money PLN
- app name must be in quotes.

Types: text, email, phone, url, int, float, decimal, bool, date, datetime, uuid, json, money(PLN)
Modifiers: @unique, @required, @generated, @index
`;

const { normalizeMiniRclSource } = require('../lib/chat-core');
const { callOllama: _callOllamaRaw, coerceToRclString, isLikelyRcl, convertLegacyJsonContractToRcl, extractContract } = require('../lib/rcl-utils');

function callOllama(messages) {
  return _callOllamaRaw(messages, OLLAMA_HOST, OLLAMA_MODEL);
}

// API Routes

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', model: OLLAMA_MODEL, ollama: OLLAMA_HOST });
});

// Session logging
const LOGS_DIR = path.join(PROJECTS_DIR, 'logs');
if (!fs.existsSync(LOGS_DIR)) fs.mkdirSync(LOGS_DIR, { recursive: true });

function saveSessionLog(history, contract, projectName = 'session') {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const logPath = path.join(LOGS_DIR, `${projectName}_${timestamp}.rcl.md`);
  
  // Extract app name from contract
  const appMatch = contract ? contract.match(/app\s+["']([^"']+)["']/) : null;
  const appName = appMatch ? appMatch[1] : projectName;
  
  // Count entities/events/enums
  const entities = contract ? (contract.match(/entity\s+\w+/g) || []).length : 0;
  const events = contract ? (contract.match(/event\s+\w+/g) || []).length : 0;
  const enums = contract ? (contract.match(/enum\s+\w+/g) || []).length : 0;
  
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0];
  const timeStr = now.toTimeString().split(' ')[0];
  
  const lines = [
    `# ${appName}`,
    ``,
    `> Generated by Reclapp Studio`,
    ``,
    `## Metadata`,
    ``,
    `| Property | Value |`,
    `|----------|-------|`,
    `| Project | ${projectName} |`,
    `| Created | ${dateStr} |`,
    `| Time | ${timeStr} |`,
    `| Messages | ${history.length} |`,
    `| Model | ${OLLAMA_MODEL} |`,
    `| Entities | ${entities} |`,
    `| Events | ${events} |`,
    `| Enums | ${enums} |`,
    ``,
    `---`,
    ``,
    `## ğŸ’¬ Conversation`,
    ``,
    `<!-- reclapp:conversation -->`,
    ``
  ];
  
  history.forEach((msg, i) => {
    const role = msg.role === 'user' ? 'ğŸ§‘ User' : 'ğŸ¤– Assistant';
    const msgTime = `${dateStr} ${timeStr}`;
    lines.push(`### ${role} (${msgTime})`);
    lines.push(``);
    lines.push(msg.content || '');
    lines.push(``);
  });
  
  lines.push(`---`);
  lines.push(``);
  
  if (contract) {
    lines.push(`## ğŸ“¦ Contract (RCL)`);
    lines.push(``);
    lines.push('```rcl');
    lines.push(contract);
    lines.push('```');
    lines.push(``);
    lines.push(`---`);
    lines.push(``);
  }
  
  lines.push(`## ğŸ“œ Actions`);
  lines.push(``);
  lines.push(`<!-- reclapp:actions -->`);
  lines.push('```action');
  lines.push(`timestamp: ${now.toISOString()}`);
  lines.push(`type: chat`);
  lines.push(`model: ${OLLAMA_MODEL}`);
  lines.push(`messages: ${history.length}`);
  lines.push(`result: success`);
  lines.push('```');
  lines.push(``);
  lines.push(`---`);
  lines.push(``);
  lines.push(`*Generated by Reclapp Studio*`);
  
  fs.writeFileSync(logPath, lines.join('\n'));
  return logPath;
}

// Auto-validation with retry
const MAX_RETRIES = 2;

function validateContractSyntax(contract) {
  if (!contract) return { valid: false, errors: ['No contract extracted'] };
  
  const errors = [];
  
  // Check app declaration
  if (!contract.match(/app\s+["']/)) {
    errors.push('Missing app declaration');
  }
  
  // Check balanced braces
  const openBraces = (contract.match(/\{/g) || []).length;
  const closeBraces = (contract.match(/\}/g) || []).length;
  if (openBraces !== closeBraces) {
    errors.push(`Unbalanced braces: ${openBraces} open, ${closeBraces} close`);
  }
  
  // Check for TypeScript syntax mistakes
  if (/:\s*string\b/i.test(contract)) {
    errors.push("Use 'text' instead of 'string'");
  }
  if (/:\s*number\b/i.test(contract)) {
    errors.push("Use 'int', 'float', or 'decimal' instead of 'number'");
  }
  
  // Check for missing required sections
  if (!contract.match(/entity\s+\w+/)) {
    errors.push('No entities defined');
  }

  // Common Mini-DSL field mistakes inside entity blocks
  // - Missing type: "email @required" (should be: "email email @required")
  // - Using modifiers without a type
  const entityBlocks = contract.match(/entity\s+\w+\s*\{[\s\S]*?\}/g) || [];
  const knownTypes = new Set([
    'text', 'email', 'phone', 'url', 'int', 'float', 'decimal', 'bool', 'date', 'datetime', 'uuid', 'json'
  ]);
  for (const block of entityBlocks) {
    const body = block.replace(/^entity\s+\w+\s*\{/, '').replace(/\}\s*$/, '');
    const lines = body.split('\n');
    for (const rawLine of lines) {
      const line = rawLine.trim();
      if (!line) continue;
      if (line.startsWith('//')) continue;

      // Ignore braces and anything that doesn't look like a field
      if (line === '{' || line === '}') continue;
      if (/^(app|entity|enum|event|alert|dashboard|pipeline|source|config)\b/.test(line)) continue;

      // If line contains modifiers but only one token before modifiers => missing type
      const tokens = line.split(/\s+/).filter(Boolean);
      const hasModifier = tokens.some(t => t.startsWith('@'));
      if (!hasModifier) continue;

      const idxFirstModifier = tokens.findIndex(t => t.startsWith('@'));
      const pre = tokens.slice(0, idxFirstModifier);

      // Expect: <fieldName> <type> ...
      if (pre.length === 1) {
        errors.push(`Entity field missing type: "${line}"`);
        continue;
      }

      // Detect "fieldName @required" etc.
      if (pre.length >= 2) {
        const typeTok = pre[1];
        if (!knownTypes.has(typeTok) && !/^->|^<-$/.test(typeTok)) {
          // Might be relation or custom type - allow Identifier-like types
          // but reject obvious modifier-as-type cases
          if (typeTok.startsWith('@')) {
            errors.push(`Entity field missing type: "${line}"`);
          }
        }
      }
    }
  }
  
  return { valid: errors.length === 0, errors };
}

function buildFixPrompt(contract, errors) {
  return `The contract has errors. Please fix them and return ONLY the corrected contract in JSON format.

ERRORS:
${errors.map(e => `- ${e}`).join('\n')}

ORIGINAL CONTRACT:
${contract}

Return ONLY valid JSON with the fixed contract:
\`\`\`json
{
  "thinking": "describe fixes",
  "contract": "fixed RCL code here",
  "summary": {"entities": [], "events": []}
}
\`\`\``;
}

// Chat with LLM (with auto-validation and retry)
app.post('/api/chat', async (req, res) => {
  const { message, history = [], projectName = 'session' } = req.body;
  
  const messages = [
    { role: 'system', content: SYSTEM_PROMPT },
    ...history,
    { role: 'user', content: message }
  ];

  try {
    let response = await callOllama(messages);
    let contract = extractContract(response);
    if (contract) contract = normalizeMiniRclSource(contract);
    let validation = validateContractSyntax(contract);
    let retries = 0;
    const fixes = [];
    
    // Auto-fix loop
    while (!validation.valid && contract && retries < MAX_RETRIES) {
      retries++;
      fixes.push({ attempt: retries, errors: validation.errors });
      
      // Ask LLM to fix errors
      const fixPrompt = buildFixPrompt(contract, validation.errors);
      const fixMessages = [
        { role: 'system', content: SYSTEM_PROMPT },
        { role: 'user', content: fixPrompt }
      ];
      
      const fixResponse = await callOllama(fixMessages);
      let fixedContract = extractContract(fixResponse);
      if (fixedContract) fixedContract = normalizeMiniRclSource(fixedContract);
      
      if (fixedContract) {
        contract = fixedContract;
        validation = validateContractSyntax(contract);
        response += `\n\n---\nğŸ”§ Auto-fix attempt ${retries}:\n${fixResponse}`;
      } else {
        break;
      }
    }
    
    // Save session log in .rcl.md format
    const updatedHistory = [...history, { role: 'user', content: message }, { role: 'assistant', content: response }];
    const logPath = saveSessionLog(updatedHistory, contract, projectName);
    
    res.json({
      success: true,
      response,
      contract,
      validation,
      fixes,
      model: OLLAMA_MODEL,
      logPath
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// List projects
app.get('/api/projects', (req, res) => {
  const projects = scanProjects();
  res.json({ success: true, projects });
});

// Get project contract
app.get('/api/projects/:source/:name/contract', (req, res) => {
  const { source, name } = req.params;
  const format = req.query.format || 'rcl';
  
  const baseDir = source === 'apps' ? APPS_DIR : EXAMPLES_DIR;
  const contractsDir = path.join(baseDir, name, 'contracts');
  
  if (!fs.existsSync(contractsDir)) {
    return res.json({ success: false, error: 'Contracts directory not found' });
  }
  
  // Find contract file by format
  const files = fs.readdirSync(contractsDir);
  let contractFile = null;
  
  for (const f of files) {
    if (format === 'md' && (f.endsWith('.rcl.md') || f.endsWith('.md'))) {
      contractFile = path.join(contractsDir, f);
      break;
    } else if (format === 'rcl' && f.endsWith('.reclapp.rcl')) {
      contractFile = path.join(contractsDir, f);
      break;
    } else if (format === 'ts' && f.endsWith('.reclapp.ts')) {
      contractFile = path.join(contractsDir, f);
      break;
    }
  }
  
  // Fallback
  if (!contractFile) {
    for (const f of files) {
      if (f.includes('.rcl') || f.includes('.ts') || f.endsWith('.md')) {
        contractFile = path.join(contractsDir, f);
        break;
      }
    }
  }
  
  if (!contractFile) {
    return res.json({ success: false, error: 'No contract file found' });
  }
  
  const content = fs.readFileSync(contractFile, 'utf-8');
  res.json({ success: true, content, file: path.basename(contractFile) });
});

// Validate contract
app.post('/api/validate', (req, res) => {
  const { contract } = req.body;
  const result = validateContract(contract);
  res.json(result);
});

// Save contract
app.post('/api/save', (req, res) => {
  const { name, contract, format = 'rcl', history = [] } = req.body;
  
  try {
    const projectDir = path.join(PROJECTS_DIR, name, 'contracts');
    fs.mkdirSync(projectDir, { recursive: true });

    const normalizedContract = normalizeMiniRclSource(contract);
    
    let filename, content;
    const savedFiles = [];
    
    // Extract app name from contract
    const appMatch = normalizedContract.match(/app\s+["']([^"']+)["']/);
    const appName = appMatch ? appMatch[1] : name;
    
    // Count entities/events/enums
    const entities = (normalizedContract.match(/entity\s+\w+/g) || []).length;
    const events = (normalizedContract.match(/event\s+\w+/g) || []).length;
    const enums = (normalizedContract.match(/enum\s+\w+/g) || []).length;
    
    const now = new Date();
    const dateStr = now.toISOString().split('T')[0];
    const timeStr = now.toTimeString().split(' ')[0];
    
    if (format === 'md' || format === 'all') {
      filename = 'main.rcl.md';
      
      // Build markdown with conversation
      let mdContent = `# ${appName}\n\n`;
      mdContent += `> Generated by Reclapp Studio\n\n`;
      mdContent += `## Metadata\n\n`;
      mdContent += `| Property | Value |\n`;
      mdContent += `|----------|-------|\n`;
      mdContent += `| Project | ${name} |\n`;
      mdContent += `| Created | ${dateStr} |\n`;
      mdContent += `| Time | ${timeStr} |\n`;
      mdContent += `| Entities | ${entities} |\n`;
      mdContent += `| Events | ${events} |\n`;
      mdContent += `| Enums | ${enums} |\n\n`;
      mdContent += `---\n\n`;
      
      // Add conversation if present
      if (history && history.length > 0) {
        mdContent += `## ğŸ’¬ Conversation\n\n`;
        mdContent += `<!-- reclapp:conversation -->\n\n`;
        
        history.forEach((msg, i) => {
          const role = msg.role === 'user' ? 'ğŸ§‘ User' : 'ğŸ¤– Assistant';
          mdContent += `### ${role}\n\n`;
          mdContent += `${msg.content}\n\n`;
        });
        
        mdContent += `---\n\n`;
      }
      
      mdContent += `## ğŸ“¦ Contract (RCL)\n\n`;
      mdContent += `\`\`\`rcl\n${normalizedContract}\n\`\`\`\n\n`;
      mdContent += `---\n\n`;
      mdContent += `*Generated by Reclapp Studio*\n`;
      
      const mdPath = path.join(projectDir, filename);
      fs.writeFileSync(mdPath, mdContent);
      savedFiles.push({ name: filename, path: mdPath, ext: 'md' });
    }
    
    if (format === 'rcl' || format === 'all') {
      filename = 'main.reclapp.rcl';
      const rclPath = path.join(projectDir, filename);
      fs.writeFileSync(rclPath, normalizedContract);
      savedFiles.push({ name: filename, path: rclPath, ext: 'rcl' });
    }
    
    if (format === 'ts' || format === 'all') {
      filename = 'main.reclapp.ts';
      const tsContent = generateTypeScriptFromRCL(normalizedContract);
      const tsPath = path.join(projectDir, filename);
      fs.writeFileSync(tsPath, tsContent);
      savedFiles.push({ name: filename, path: tsPath, ext: 'ts' });
    }
    
    res.json({ 
      success: true, 
      path: savedFiles[0]?.path || projectDir,
      files: savedFiles.map(f => ({
        name: f.name,
        path: `projects/${name}/contracts/${f.name}`,
        absPath: f.path,
        ext: f.ext
      }))
    });
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Generate project (calls reclapp CLI)
app.post('/api/generate', (req, res) => {
  const { source, name } = req.body;
  
  const baseDir = source === 'apps' ? APPS_DIR : (source === 'examples' ? EXAMPLES_DIR : PROJECTS_DIR);
  const projectDir = path.join(baseDir, name);
  const contractsDir = path.join(projectDir, 'contracts');
  
  // Find contract file
  if (!fs.existsSync(contractsDir)) {
    return res.json({ success: false, error: 'No contracts directory' });
  }
  
  const files = fs.readdirSync(contractsDir);
  let contractFile = files.find(f => f.endsWith('.reclapp.rcl') || f.endsWith('.reclapp.ts'));
  
  if (!contractFile) {
    return res.json({ success: false, error: 'No .rcl or .ts contract found' });
  }
  
  const contractPath = path.join(contractsDir, contractFile);
  const targetDir = path.join(projectDir, 'target');
  
  // Return command to run (we don't execute it directly for safety)
  res.json({
    success: true,
    command: `./bin/reclapp generate ${contractPath} -o ${targetDir}`,
    contractPath,
    targetDir
  });
});

// Auto-generate formats from existing contract
app.post('/api/auto-generate', (req, res) => {
  const { source, name } = req.body;
  
  const baseDir = source === 'apps' ? APPS_DIR : (source === 'examples' ? EXAMPLES_DIR : PROJECTS_DIR);
  const projectDir = path.join(baseDir, name);
  const contractsDir = path.join(projectDir, 'contracts');
  
  if (!fs.existsSync(contractsDir)) {
    return res.json({ success: false, error: 'No contracts directory' });
  }
  
  const files = fs.readdirSync(contractsDir);
  const generated = [];
  
  // Find existing contract
  let rclContent = null;
  let rclFile = files.find(f => f.endsWith('.reclapp.rcl'));
  let mdFile = files.find(f => f.endsWith('.rcl.md') || f.endsWith('.md'));
  let tsFile = files.find(f => f.endsWith('.reclapp.ts'));
  
  // Read RCL if exists
  if (rclFile) {
    rclContent = fs.readFileSync(path.join(contractsDir, rclFile), 'utf-8');
  } else if (mdFile) {
    // Extract RCL from markdown
    const mdContent = fs.readFileSync(path.join(contractsDir, mdFile), 'utf-8');
    const rclMatch = mdContent.match(/```rcl\s*([\s\S]*?)\s*```/);
    if (rclMatch) {
      rclContent = rclMatch[1];
      // Save as .rcl
      const newRclFile = mdFile.replace('.rcl.md', '.reclapp.rcl').replace('.md', '.reclapp.rcl');
      fs.writeFileSync(path.join(contractsDir, newRclFile), rclContent);
      generated.push(newRclFile);
    }
  }
  
  if (!rclContent) {
    return res.json({ success: false, error: 'No contract content found' });
  }
  
  // Generate missing formats
  if (!mdFile) {
    const appMatch = rclContent.match(/app\s+["']([^"']+)["']/);
    const appName = appMatch ? appMatch[1] : name;
    const mdContent = `# ${appName}\n\n> Generated by Reclapp Studio\n\n## Contract\n\n\`\`\`rcl\n${rclContent}\n\`\`\`\n`;
    fs.writeFileSync(path.join(contractsDir, 'main.rcl.md'), mdContent);
    generated.push('main.rcl.md');
  }
  
  if (!tsFile) {
    const tsContent = generateTypeScriptFromRCL(rclContent);
    fs.writeFileSync(path.join(contractsDir, 'main.reclapp.ts'), tsContent);
    generated.push('main.reclapp.ts');
  }
  
  res.json({ 
    success: true, 
    generated,
    message: generated.length > 0 ? `Generated ${generated.length} files` : 'All formats already exist'
  });
});

// Helper to generate TypeScript
function generateTypeScriptFromRCL(rcl) {
  const appMatch = rcl.match(/app\s+["']([^"']+)["']/);
  const appName = appMatch ? appMatch[1] : 'App';
  
  let ts = `/**
 * ${appName} - Reclapp Contract
 * Generated: ${new Date().toISOString()}
 */

import type { ReclappContract, Entity } from '@reclapp/contracts';

`;

  const entityRegex = /entity\s+(\w+)\s*\{([^}]*)\}/g;
  let match;
  const entities = [];
  
  while ((match = entityRegex.exec(rcl)) !== null) {
    const [, eName, body] = match;
    entities.push(eName);
    ts += `export interface ${eName} {\n`;
    const lines = body.split('\n').map(l => l.trim()).filter(Boolean);
    for (const line of lines) {
      const fieldMatch = line.match(/^(\w+)\s+(\w+)/);
      if (fieldMatch) {
        const typeMap = { uuid: 'string', text: 'string', email: 'string', int: 'number', float: 'number', bool: 'boolean', date: 'Date', datetime: 'Date', decimal: 'number' };
        ts += `  ${fieldMatch[1]}: ${typeMap[fieldMatch[2]] || fieldMatch[2]};\n`;
      }
    }
    ts += `}\n\n`;
  }
  
  ts += `export const contract: ReclappContract = {
  app: { name: '${appName}', version: '1.0.0' },
  entities: [${entities.map(e => `'${e}'`).join(', ')}]
};

export default contract;
`;
  return ts;
}

// Run project - generate and start servers
app.post('/api/run', async (req, res) => {
  const { source, name, action = 'start', autoGenerate = true, contract = null } = req.body;
  const { spawn } = require('child_process');
  
  const baseDir = source === 'apps' ? APPS_DIR : (source === 'examples' ? EXAMPLES_DIR : PROJECTS_DIR);
  const projectDir = path.join(baseDir, name);
  const targetDir = path.join(projectDir, 'target');
  const contractsDir = path.join(projectDir, 'contracts');

  const isProcessAlive = (pid) => {
    if (!pid) return false;
    try {
      process.kill(pid, 0);
      return true;
    } catch {
      return false;
    }
  };

  const isPortFree = (port) => {
    return new Promise((resolve) => {
      const s = net.createServer();
      s.once('error', () => resolve(false));
      s.once('listening', () => s.close(() => resolve(true)));
      s.listen(port, '127.0.0.1');
    });
  };

  const runCommand = (cmd, args, cwd, env) => {
    return new Promise((resolve, reject) => {
      const p = spawn(cmd, args, {
        cwd,
        env: { ...process.env, ...(env || {}) },
        stdio: ['ignore', 'pipe', 'pipe'],
        shell: false
      });
      let stdout = '';
      let stderr = '';
      p.stdout.on('data', (d) => (stdout += d.toString()));
      p.stderr.on('data', (d) => (stderr += d.toString()));
      p.on('close', (code) => {
        if (code === 0) {
          resolve({ stdout, stderr });
        } else {
          reject(new Error(`${cmd} ${args.join(' ')} exited with code ${code}\n${stderr || stdout}`));
        }
      });
    });
  };
  
  try {
    if (typeof name !== 'string' || !name.trim() || /\.\.|\//.test(name)) {
      return res.json({ success: false, error: 'Invalid project name' });
    }

    const existing = runningProjects.get(name);
    if (existing && isProcessAlive(existing.apiPid) && isProcessAlive(existing.frontendPid)) {
      return res.json({
        success: true,
        message: `Project ${name} already running`,
        urls: existing.urls,
        command: existing.command,
        uri: existing.uri
      });
    }

    // Create contracts dir if doesn't exist
    if (!fs.existsSync(contractsDir)) {
      fs.mkdirSync(contractsDir, { recursive: true });
    }
    
    // Save contract if provided
    if (contract) {
      const rclPath = path.join(contractsDir, 'main.reclapp.rcl');
      fs.writeFileSync(rclPath, contract);
      console.log(`Saved contract to ${rclPath}`);
    }
    
    // Auto-generate formats
    const files = fs.readdirSync(contractsDir);
    let rclFile = files.find(f => f.endsWith('.reclapp.rcl'));
    
    if (!rclFile) {
      // Try to extract from .md
      const mdFile = files.find(f => f.endsWith('.rcl.md') || f.endsWith('.md'));
      if (mdFile) {
        const mdContent = fs.readFileSync(path.join(contractsDir, mdFile), 'utf-8');
        const rclMatch = mdContent.match(/```rcl\s*([\s\S]*?)\s*```/);
        if (rclMatch) {
          fs.writeFileSync(path.join(contractsDir, 'main.reclapp.rcl'), rclMatch[1]);
          rclFile = 'main.reclapp.rcl';
        }
      }
    }
    
    if (!rclFile) {
      return res.json({
        success: false,
        error: 'No contract file found. Save the contract first.',
        needsSave: true
      });
    }
    
    const contractPath = path.join(contractsDir, rclFile);
    const repoRoot = path.join(__dirname, '..');
    const reclappBin = path.join(repoRoot, 'bin', 'reclapp');
    const generateCmd = `${process.execPath} ${reclappBin} generate ${contractPath} -o ${targetDir}`;

    if (autoGenerate) {
      const needsGenerate = !fs.existsSync(targetDir) || !fs.existsSync(path.join(targetDir, 'api'));
      if (needsGenerate) {
        await runCommand(process.execPath, [reclappBin, 'generate', contractPath, '-o', targetDir], repoRoot);
      }
    }

    if (!fs.existsSync(targetDir)) {
      return res.json({ success: false, error: 'Target not built.', needsGenerate: true, generateCommand: generateCmd, contractPath, targetDir });
    }
    
    const apiDir = path.join(targetDir, 'api');
    const frontendDir = path.join(targetDir, 'frontend');

    const apiPort = 8080;
    const frontendPort = 3000;

    const apiPortFree = await isPortFree(apiPort);
    const frontendPortFree = await isPortFree(frontendPort);
    if (!apiPortFree || !frontendPortFree) {
      return res.json({
        success: false,
        error: `Ports in use. Need API:${apiPort} and Frontend:${frontendPort}. Stop other processes and try again.`,
        ports: { api: apiPort, frontend: frontendPort }
      });
    }
    
    const urls = {
      api: null,
      frontend: null,
      dashboard: null
    };
    
    // Start API if exists
    if (fs.existsSync(apiDir) && fs.existsSync(path.join(apiDir, 'package.json'))) {
      urls.api = `http://localhost:${apiPort}`;
    }
    
    // Start Frontend if exists
    if (fs.existsSync(frontendDir) && fs.existsSync(path.join(frontendDir, 'package.json'))) {
      urls.frontend = `http://localhost:${frontendPort}`;
    }
    
    // Dashboard URL
    urls.dashboard = `http://localhost:${frontendPort}`;
    
    if (action === 'start') {
      if (urls.api && fs.existsSync(path.join(apiDir, 'package.json'))) {
        await runCommand('npm', ['install', '--silent'], apiDir, undefined).catch(() => undefined);
        const apiProc = spawn('npm', ['run', 'dev'], {
          cwd: apiDir,
          env: { ...process.env, PORT: String(apiPort) },
          detached: true,
          stdio: 'ignore',
          shell: true
        });
        apiProc.unref();
        urls.api = `http://localhost:${apiPort}`;
        runningProjects.set(name, { ...(runningProjects.get(name) || {}), apiPid: apiProc.pid });
      }

      if (urls.frontend && fs.existsSync(path.join(frontendDir, 'package.json'))) {
        await runCommand('npm', ['install', '--silent'], frontendDir, undefined).catch(() => undefined);
        const frontendProc = spawn('npm', ['run', 'dev', '--', '--host', '0.0.0.0', '--port', String(frontendPort)], {
          cwd: frontendDir,
          env: { ...process.env },
          detached: true,
          stdio: 'ignore',
          shell: true
        });
        frontendProc.unref();
        urls.frontend = `http://localhost:${frontendPort}`;
        urls.dashboard = urls.frontend;
        const existingRun = runningProjects.get(name) || {};
        runningProjects.set(name, { ...existingRun, frontendPid: frontendProc.pid });
      }
    }

    const command = `API: PORT=${apiPort} (api/) | Frontend: vite --port ${frontendPort} (frontend/)`;
    const uri = `reclapp://${name}?api=${apiPort}&frontend=${frontendPort}`;
    const existingRun = runningProjects.get(name) || {};
    runningProjects.set(name, { ...existingRun, urls, command, uri });

    res.json({
      success: true,
      message: `Project ${name} running`,
      urls,
      command,
      uri,
      contractPath,
      targetDir
    });
    
  } catch (error) {
    res.json({ success: false, error: error.message });
  }
});

// Open in browser/system
app.post('/api/open', (req, res) => {
  const { url } = req.body;
  const { exec } = require('child_process');
  
  // Detect OS and open URL
  const platform = process.platform;
  let cmd;
  
  if (platform === 'linux') {
    cmd = `xdg-open "${url}"`;
  } else if (platform === 'darwin') {
    cmd = `open "${url}"`;
  } else if (platform === 'win32') {
    cmd = `start "" "${url}"`;
  }
  
  if (cmd) {
    exec(cmd, (error) => {
      if (error) {
        res.json({ success: false, error: error.message });
      } else {
        res.json({ success: true, message: `Opened ${url}` });
      }
    });
  } else {
    res.json({ success: false, error: 'Unsupported platform' });
  }
});

// Helper functions (callOllama, coerceToRclString, isLikelyRcl,
// convertLegacyJsonContractToRcl, extractContract imported from lib/rcl-utils.js)

function validateContract(contract) {
  const errors = [];
  const warnings = [];
  
  // Check app declaration
  if (!contract.match(/app\s+["']/)) {
    errors.push('Missing app declaration');
  }
  
  // Check balanced braces
  const openBraces = (contract.match(/\{/g) || []).length;
  const closeBraces = (contract.match(/\}/g) || []).length;
  if (openBraces !== closeBraces) {
    errors.push(`Unbalanced braces: ${openBraces} open, ${closeBraces} close`);
  }
  
  // Check for TypeScript syntax mistakes
  if (/:\s*string\b/i.test(contract)) {
    errors.push("Invalid type 'string'. Use 'text' instead.");
  }
  if (/:\s*number\b/i.test(contract)) {
    errors.push("Invalid type 'number'. Use 'int', 'float', or 'decimal'.");
  }
  
  // Count elements
  const entities = (contract.match(/entity\s+\w+/g) || []).length;
  const events = (contract.match(/event\s+\w+/g) || []).length;
  const enums = (contract.match(/enum\s+\w+/g) || []).length;
  
  return {
    valid: errors.length === 0,
    errors,
    warnings,
    stats: { entities, events, enums }
  };
}

function scanProjects() {
  const projects = [];
  
  for (const [dir, source] of [[APPS_DIR, 'apps'], [EXAMPLES_DIR, 'examples']]) {
    if (!fs.existsSync(dir)) continue;
    
    for (const name of fs.readdirSync(dir)) {
      const projectDir = path.join(dir, name);
      if (!fs.statSync(projectDir).isDirectory()) continue;
      
      const contractsDir = path.join(projectDir, 'contracts');
      const targetDir = path.join(projectDir, 'target');
      
      if (!fs.existsSync(contractsDir)) continue;
      
      const files = fs.readdirSync(contractsDir);
      const formats = {
        md: files.some(f => f.endsWith('.rcl.md') || f.endsWith('.md')),
        rcl: files.some(f => f.endsWith('.reclapp.rcl')),
        ts: files.some(f => f.endsWith('.reclapp.ts'))
      };
      
      const hasTarget = fs.existsSync(targetDir) && fs.readdirSync(targetDir).length > 0;
      
      projects.push({
        name,
        source,
        path: projectDir,
        formats,
        hasTarget,
        status: hasTarget ? 'built' : 'not_built'
      });
    }
  }
  
  return projects;
}

// Start server
app.listen(PORT, () => {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ğŸš€ RECLAPP STUDIO                             â•‘
â•‘           Simple Web UI (no Gradio)                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŒ Web UI:    http://localhost:${PORT}
ğŸ¤– LLM:       ${OLLAMA_MODEL} @ ${OLLAMA_HOST}
ğŸ“ Projects:  ${PROJECTS_DIR}

API Endpoints:
  GET  /api/health              - Health check
  POST /api/chat                - Chat with LLM
  GET  /api/projects            - List projects
  GET  /api/projects/:s/:n/contract - Get contract
  POST /api/validate            - Validate contract
  POST /api/save                - Save contract
  POST /api/generate            - Generate project
`);
});
