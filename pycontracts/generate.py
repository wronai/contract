#!/usr/bin/env python3
"""
Contract Schema Generator

Generates JSON Schemas and TypeScript types from Pydantic contracts.

Usage:
    python -m pycontracts.generate
    python -m pycontracts.generate --output ./contracts
    python -m pycontracts.generate --typescript --output ./frontend-sdk

@version 2.3.0
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Any, Dict, List, Type

from pydantic import BaseModel

from .base import (
    ContractAI,
    EntityField,
    EntityDefinition,
    FieldAnnotations,
    CodeAssertion,
)
from .entities import Contact, Company, Deal, User, Task, Project
from .llm import LLMCodeOutput, GeneratedFile, ValidationResult, PipelineResult


# ============================================================================
# SCHEMA GENERATION
# ============================================================================

def generate_json_schema(model: Type[BaseModel]) -> Dict[str, Any]:
    """Generate JSON Schema from Pydantic model"""
    return model.model_json_schema()


def save_json_schema(model: Type[BaseModel], output_dir: Path, prefix: str = "") -> str:
    """Save JSON Schema to file"""
    schema = generate_json_schema(model)
    
    name = model.__name__
    if prefix:
        filename = f"{prefix}/{name.lower()}.json"
    else:
        filename = f"{name.lower()}.json"
    
    filepath = output_dir / filename
    filepath.parent.mkdir(parents=True, exist_ok=True)
    
    with open(filepath, "w") as f:
        json.dump(schema, f, indent=2)
    
    return str(filepath)


# ============================================================================
# TYPESCRIPT GENERATION
# ============================================================================

def json_schema_to_typescript(schema: Dict[str, Any], name: str) -> str:
    """Convert JSON Schema to TypeScript interface"""
    lines = []
    
    # Add description as comment
    if "description" in schema:
        lines.append(f"/** {schema['description']} */")
    
    lines.append(f"export interface {name} {{")
    
    properties = schema.get("properties", {})
    required = set(schema.get("required", []))
    
    for prop_name, prop_schema in properties.items():
        ts_type = json_type_to_typescript(prop_schema)
        optional = "" if prop_name in required else "?"
        
        # Add property description
        if "description" in prop_schema:
            lines.append(f"  /** {prop_schema['description']} */")
        
        lines.append(f"  {prop_name}{optional}: {ts_type};")
    
    lines.append("}")
    return "\n".join(lines)


def json_type_to_typescript(schema: Dict[str, Any]) -> str:
    """Convert JSON Schema type to TypeScript type"""
    if "$ref" in schema:
        ref = schema["$ref"].split("/")[-1]
        return ref
    
    json_type = schema.get("type", "any")
    
    if json_type == "string":
        if "enum" in schema:
            return " | ".join(f'"{v}"' for v in schema["enum"])
        if schema.get("format") == "date-time":
            return "string"
        if schema.get("format") == "date":
            return "string"
        if schema.get("format") == "email":
            return "string"
        if schema.get("format") == "uri":
            return "string"
        return "string"
    
    if json_type == "integer" or json_type == "number":
        return "number"
    
    if json_type == "boolean":
        return "boolean"
    
    if json_type == "array":
        items_type = json_type_to_typescript(schema.get("items", {}))
        return f"{items_type}[]"
    
    if json_type == "object":
        if "additionalProperties" in schema:
            value_type = json_type_to_typescript(schema["additionalProperties"])
            return f"Record<string, {value_type}>"
        return "Record<string, unknown>"
    
    if json_type == "null":
        return "null"
    
    if isinstance(json_type, list):
        types = [json_type_to_typescript({"type": t}) for t in json_type]
        return " | ".join(types)
    
    # Handle anyOf/oneOf
    if "anyOf" in schema or "oneOf" in schema:
        options = schema.get("anyOf", schema.get("oneOf", []))
        types = [json_type_to_typescript(opt) for opt in options]
        return " | ".join(types)
    
    return "unknown"


def generate_typescript_file(models: List[Type[BaseModel]], header: str = "") -> str:
    """Generate TypeScript file from multiple models"""
    lines = [
        "/**",
        " * Auto-generated TypeScript types from Pydantic contracts",
        " * DO NOT EDIT - Generated by pycontracts.generate",
        " */",
        "",
    ]
    
    if header:
        lines.insert(1, f" * {header}")
    
    for model in models:
        schema = generate_json_schema(model)
        ts_code = json_schema_to_typescript(schema, model.__name__)
        lines.append(ts_code)
        lines.append("")
    
    return "\n".join(lines)


# ============================================================================
# MAIN GENERATION
# ============================================================================

ENTITY_MODELS = [Contact, Company, Deal, User, Task, Project]
LLM_MODELS = [GeneratedFile, LLMCodeOutput, PipelineResult, ValidationResult]
CONTRACT_MODELS = [EntityField, EntityDefinition, CodeAssertion, ContractAI]


def generate_all_schemas(output_dir: Path) -> List[str]:
    """Generate all JSON Schemas"""
    generated = []
    
    # Entities
    for model in ENTITY_MODELS:
        path = save_json_schema(model, output_dir, "entities")
        generated.append(path)
        print(f"  ‚úì {path}")
    
    # LLM outputs
    for model in LLM_MODELS:
        path = save_json_schema(model, output_dir, "llm")
        generated.append(path)
        print(f"  ‚úì {path}")
    
    # Contract types
    for model in CONTRACT_MODELS:
        path = save_json_schema(model, output_dir, "contracts")
        generated.append(path)
        print(f"  ‚úì {path}")
    
    return generated


def generate_all_typescript(output_dir: Path) -> List[str]:
    """Generate all TypeScript types"""
    generated = []
    
    # Entities
    ts_entities = generate_typescript_file(ENTITY_MODELS, "Entity Types")
    entities_path = output_dir / "types" / "entities.ts"
    entities_path.parent.mkdir(parents=True, exist_ok=True)
    entities_path.write_text(ts_entities)
    generated.append(str(entities_path))
    print(f"  ‚úì {entities_path}")
    
    # LLM types
    ts_llm = generate_typescript_file(LLM_MODELS, "LLM Output Types")
    llm_path = output_dir / "types" / "llm.ts"
    llm_path.write_text(ts_llm)
    generated.append(str(llm_path))
    print(f"  ‚úì {llm_path}")
    
    # Index file
    index_content = '''/**
 * Pydantic Contracts - TypeScript Types
 * Auto-generated - DO NOT EDIT
 */

export * from './entities';
export * from './llm';
'''
    index_path = output_dir / "types" / "index.ts"
    index_path.write_text(index_content)
    generated.append(str(index_path))
    print(f"  ‚úì {index_path}")
    
    return generated


def main():
    parser = argparse.ArgumentParser(
        description="Generate JSON Schemas and TypeScript types from Pydantic contracts"
    )
    parser.add_argument(
        "--output", "-o",
        type=Path,
        default=Path("./contracts/json"),
        help="Output directory for JSON Schemas"
    )
    parser.add_argument(
        "--typescript", "-t",
        action="store_true",
        help="Also generate TypeScript types"
    )
    parser.add_argument(
        "--ts-output",
        type=Path,
        default=Path("./frontend-sdk"),
        help="Output directory for TypeScript types"
    )
    
    args = parser.parse_args()
    
    print("‚ïê" * 60)
    print("  Pydantic Contract Generator v2.3.0")
    print("‚ïê" * 60)
    print()
    
    # Generate JSON Schemas
    print("üìã Generating JSON Schemas...")
    args.output.mkdir(parents=True, exist_ok=True)
    schemas = generate_all_schemas(args.output)
    print(f"\n  Generated {len(schemas)} schemas\n")
    
    # Generate TypeScript if requested
    if args.typescript:
        print("üìù Generating TypeScript types...")
        args.ts_output.mkdir(parents=True, exist_ok=True)
        ts_files = generate_all_typescript(args.ts_output)
        print(f"\n  Generated {len(ts_files)} TypeScript files\n")
    
    print("‚ïê" * 60)
    print("  ‚úÖ Generation complete!")
    print("‚ïê" * 60)


if __name__ == "__main__":
    main()
