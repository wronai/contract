#!/usr/bin/env node
/**
 * Reclapp CLI - Generate applications from DSL contracts
 * 
 * Uses generator modules from generator/ folder
 */

const path = require('path');
const fs = require('fs');

function loadEnvFromFile() {
  try {
    const envPath = path.join(__dirname, '..', '.env');
    if (!fs.existsSync(envPath)) return;
    const raw = fs.readFileSync(envPath, 'utf-8');
    const skippedKeys = [];
    for (const lineRaw of raw.split(/\r?\n/)) {
      const line = lineRaw.trim();
      if (!line || line.startsWith('#')) continue;
      const idx = line.indexOf('=');
      if (idx <= 0) continue;
      const key = line.slice(0, idx).trim();
      if (!key) continue;
      if (process.env[key] !== undefined) {
        skippedKeys.push(key);
        continue;
      }
      let value = line.slice(idx + 1).trim();
      if (
        (value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))
      ) {
        value = value.slice(1, -1);
      }
      process.env[key] = value;
    }

    if ((process.argv.includes('--verbose') || process.argv.includes('-v')) && skippedKeys.length > 0) {
      const uniq = Array.from(new Set(skippedKeys));
      console.log(`‚ÑπÔ∏è  .env loaded (did not override existing env): ${uniq.slice(0, 12).join(', ')}${uniq.length > 12 ? '‚Ä¶' : ''}`);
    }
  } catch {
    return;
  }
}

loadEnvFromFile();

// Register TypeScript support
try {
  require('ts-node').register({
    transpileOnly: true,
    compilerOptions: {
      module: 'commonjs',
      target: 'ES2022',
      esModuleInterop: true,
      skipLibCheck: true
    }
  });
} catch (e) {
  try { require('tsx/cjs'); } catch (e2) { }
}

// Import generator after ts-node registration
let SimpleGenerator, generateFromContract;
try {
  const gen = require('../generator/core/simple-generator');
  SimpleGenerator = gen.SimpleGenerator;
  generateFromContract = gen.generateFromContract;
} catch (e) {
  // Fallback: use inline generator if module not found
  SimpleGenerator = null;
}

// Import Mini-DSL parser
let parseMini, parseMiniFile, miniToIR, irToMini;
try {
  const mini = require('../dsl/parser/mini');
  parseMini = mini.parseMini;
  parseMiniFile = mini.parseMiniFile;
  miniToIR = mini.miniToIR;
  irToMini = mini.irToMini;
} catch (e) {
  parseMiniFile = null;
}

// Import shared normalization helpers (used to auto-fix common LLM mistakes)
let normalizeMiniRclSource;
try {
  ({ normalizeMiniRclSource } = require('../lib/chat-core'));
} catch (e) {
  normalizeMiniRclSource = null;
}

// Import Markdown parser (.rcl.md)
let parseMarkdownFile, irToContract, writeMarkdownContract, contractToIR;
try {
  const md = require('../dsl/parser/markdown');
  parseMarkdownFile = md.parseMarkdownFile;
  irToContract = md.irToContract;
  const writer = require('../dsl/writer/markdown');
  writeMarkdownContract = writer.writeMarkdownContract;
  contractToIR = writer.contractToIR;
} catch (e) {
  parseMarkdownFile = null;
}

// Import Contract Markdown parser (.contract.md)
let parseContractMarkdown, validateContractMarkdown, convertToContractAI;
try {
  const parser = require('../src/core/contract-ai/parser/markdown-parser');
  parseContractMarkdown = parser.parseContractMarkdown;
  validateContractMarkdown = parser.validateContract;
  const converter = require('../src/core/contract-ai/converter/to-contract-ai');
  convertToContractAI = converter.convertToContractAI;
} catch (e) {
  parseContractMarkdown = null;
}

const HELP = `
Reclapp CLI - Generate applications from DSL contracts

Usage:
  reclapp <contract.reclapp.ts|.rcl>         Generate application
  reclapp run <contract>                     Generate, install, and run
  reclapp test <contract>                    Generate, run, and test API
  reclapp dev <contract>                     Generate and start dev servers
  reclapp deploy <contract>                  Generate and deploy with Docker
  reclapp parse <contract>                   Parse contract and print JSON
  reclapp validate <contract>                Validate contract
  reclapp convert <input> -o <output>        Convert between formats
  reclapp normalize <input> [-o <output>]    Normalize Mini-DSL (.reclapp.rcl)
  reclapp list                               List available contracts
  reclapp studio                             Interactive examples browser
  reclapp chat                               Interactive LLM contract designer
  reclapp generate-ai <contract|--prompt>    Generate code with Contract AI 2.2
  reclapp evolve --prompt "..." [-k] [--no-menu] [--log-file <path>]  Evolution mode with auto-healing
  reclapp analyze <dir>                      Analyze codebase, find duplicates
  reclapp reverse <dir>                      Generate .rcl.md contract from existing code
  reclapp refactor <git-url|dir>             Clone repo, analyze, generate contract
  reclapp tasks <file.tasks>                 Run tasks from file (Dockerfile-style)
  reclapp setup                              Check environment and create setup tasks
  reclapp stop                               Stop all running containers

Commands:
  generate    Generate full application to target/ folder
  run         Generate, install dependencies, and start servers
  test        Generate, run servers, and execute API tests
  dev         Generate and start development servers (API + Frontend)
  deploy      Generate and deploy with Docker Compose
  parse       Parse contract and print JSON
  validate    Validate contract without generating
  convert     Convert between .reclapp.ts, .rcl (Mini-DSL) formats
  normalize   Normalize Mini-DSL source (fix common LLM mistakes)
  list        List all available contract files (.reclapp.ts, .rcl)
  studio      Interactive examples browser with tests
  generate-ai Generate code using Contract AI 2.2 (LLM-driven)
  evolve      Evolution mode - dynamic code gen, monitoring, auto-fix
  reverse     Reverse-engineer a contract from an existing application
  tasks       Run tasks from file (parallel, with live markdown output)
  setup       Check environment, detect missing dependencies, create setup tasks
  stop        Stop all running Docker containers

Supported Formats:
  .reclapp.ts    TypeScript contract (original format)
  .reclapp.rcl   Mini-DSL contract (~87% less code)
  .rcl.md        Markdown contract (human-readable, AI-friendly)
  .contract.md   Contract Markdown 3.0 (LLM-optimized, full-stack)

Options:
  --output, -o <dir>    Output directory (default: ./target)
  --port <port>         API port (default: 8080)
  --verbose, -v         Verbose output
  --docker, -d          Auto-start Docker containers after generation
  --help, -h            Show this help

Examples:
  reclapp examples/crm/contracts/main.reclapp.ts
  reclapp examples/crm/contracts/main.reclapp.rcl
  reclapp examples/crm/contracts/main.rcl.md
  reclapp convert contract.rcl --format md
  reclapp convert contract.rcl.md --format ts
  reclapp normalize apps/my-app/contracts/main.reclapp.rcl -o /tmp/main.reclapp.rcl
  reclapp studio
`;

// ============================================================================
// CONTRACT LOADING
// ============================================================================

async function loadContract(contractPath) {
  const fullPath = path.resolve(contractPath);
  
  if (!fs.existsSync(fullPath)) {
    console.error(`‚ùå Contract file not found: ${fullPath}`);
    process.exit(1);
  }

  // Handle Contract Markdown (.contract.md) files - new format
  if (fullPath.endsWith('.contract.md')) {
    if (!parseContractMarkdown) {
      console.error('‚ùå Contract Markdown parser not available');
      process.exit(1);
    }
    try {
      const content = fs.readFileSync(fullPath, 'utf-8');
      const parsed = parseContractMarkdown(content);
      const validation = validateContractMarkdown(parsed);
      
      if (!validation.valid) {
        console.error('‚ùå Contract validation failed:');
        validation.errors.forEach(e => console.error(`   - ${e}`));
        process.exit(1);
      }
      
      if (validation.warnings.length > 0) {
        console.warn('‚ö†Ô∏è  Warnings:');
        validation.warnings.forEach(w => console.warn(`   - ${w}`));
      }
      
      // Convert to ContractAI format for generation
      const contractAI = convertToContractAI(parsed);
      return contractAI;
    } catch (e) {
      console.error('‚ùå Parse error:', e.message);
      process.exit(1);
    }
  }

  // Handle Markdown (.rcl.md or .md) files
  if (fullPath.endsWith('.rcl.md') || (fullPath.endsWith('.md') && fs.readFileSync(fullPath, 'utf-8').includes('# entity:'))) {
    if (!parseMarkdownFile) {
      console.error('‚ùå Markdown parser not available');
      process.exit(1);
    }
    const result = parseMarkdownFile(fullPath);
    if (!result.success) {
      console.error('‚ùå Parse error:', result.errors[0]?.message || 'Unknown error');
      if (result.errors[0]?.line) {
        console.error(`   Line ${result.errors[0].line}`);
      }
      process.exit(1);
    }
    return irToContract(result.ir);
  }

  // Handle Mini-DSL (.rcl) files
  if (fullPath.endsWith('.rcl')) {
    if (!parseMiniFile) {
      console.error('‚ùå Mini-DSL parser not available');
      process.exit(1);
    }
    let result = parseMiniFile(fullPath);
    if (!result.success && normalizeMiniRclSource && parseMini) {
      try {
        const originalSource = fs.readFileSync(fullPath, 'utf-8');
        const normalizedSource = normalizeMiniRclSource(originalSource);
        result = parseMini(normalizedSource);
      } catch (e) {
        // ignore and fall through to error reporting
      }
    }
    if (!result.success) {
      console.error('‚ùå Parse error:', result.errors[0]?.message || 'Unknown error');
      console.error(`   Line ${result.errors[0]?.line}, Column ${result.errors[0]?.column}`);
      if (normalizeMiniRclSource) {
        console.error('   Hint: This contract may contain LLM-style syntax like field: type, or trailing commas.');
        console.error('         Re-save the contract from Reclapp Studio or use a normalized format.');
      }
      process.exit(1);
    }
    const ir = miniToIR(result.ast);
    return {
      app: ir.app,
      entities: ir.entities,
      events: ir.events,
      pipelines: ir.pipelines,
      alerts: ir.alerts,
      dashboards: ir.dashboards,
      sources: ir.sources,
      workflows: ir.workflows,
      config: ir.config
    };
  }

  // Handle TypeScript (.ts) files
  delete require.cache[require.resolve(fullPath)];
  const module = require(fullPath);
  const contract = module.contract || module.default || module;

  if (!contract.app?.name) {
    console.error('‚ùå Invalid contract - missing app.name');
    process.exit(1);
  }

  return contract;
}

// ============================================================================
// COMMANDS
// ============================================================================

async function cmdGenerate(contractPath, options) {
  const contract = await loadContract(contractPath);
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  
  if (SimpleGenerator) {
    const generator = new SimpleGenerator(contract, outputDir);
    const files = generator.generate();
    const written = generator.writeFiles(options.verbose);
    console.log(`\n‚úÖ Generated ${written} files to ${outputDir}`);

    // Save contract for reverse engineering
    const contractSaveDir = path.join(outputDir, 'contract');
    if (!fs.existsSync(contractSaveDir)) fs.mkdirSync(contractSaveDir, { recursive: true });
    fs.writeFileSync(path.join(contractSaveDir, 'contract.ai.json'), JSON.stringify(contract, null, 2));
  } else {
    // Fallback inline generator (simplified)
    console.log(`\nüöÄ Generating ${contract.app.name} v${contract.app.version}...`);
    console.log(`üìÅ Output: ${outputDir}\n`);
    const InlineGenerator = require('./inline-generator');
    const gen = new InlineGenerator(contract, outputDir);
    const files = gen.generate();
    const written = gen.writeFiles(options.verbose);
    console.log(`\n‚úÖ Generated ${written} files to ${outputDir}`);

    // Save contract for reverse engineering
    const contractSaveDir = path.join(outputDir, 'contract');
    if (!fs.existsSync(contractSaveDir)) fs.mkdirSync(contractSaveDir, { recursive: true });
    fs.writeFileSync(path.join(contractSaveDir, 'contract.ai.json'), JSON.stringify(contract, null, 2));
  }

  // Auto-start Docker if --docker flag is set
  if (options.docker) {
    console.log('\nüê≥ Starting Docker containers...');
    await startDocker(outputDir);
  } else {
    console.log(`
üì¶ Next steps:
  cd ${path.relative(process.cwd(), outputDir)}/api && npm install && npm run dev
  cd ${path.relative(process.cwd(), outputDir)}/frontend && npm install && npm run dev

üê≥ Or use Docker:
  cd ${path.relative(process.cwd(), outputDir)} && docker compose up -d
  
  Or run: reclapp deploy ${contractPath}
`);
  }
}

async function startDocker(outputDir) {
  const { execSync } = require('child_process');
  
  try {
    // Stop existing containers
    console.log('   Stopping existing containers...');
    execSync('docker compose down --remove-orphans 2>/dev/null || true', { cwd: outputDir, stdio: 'pipe' });
    
    // Build and start
    console.log('   Building containers...');
    execSync('docker compose build', { cwd: outputDir, stdio: 'inherit' });
    
    console.log('   Starting containers...');
    execSync('docker compose up -d', { cwd: outputDir, stdio: 'inherit' });
    
    console.log('\n‚úÖ Docker containers started!');
    console.log('   API:      http://localhost:8080');
    console.log('   Frontend: http://localhost:3000');
    console.log('\n   View logs: docker compose logs -f');
    console.log('   Stop:      docker compose down');
  } catch (err) {
    console.error('‚ùå Docker failed. Make sure Docker is running.');
    console.log('\nüì¶ Run manually:');
    console.log(`   cd ${outputDir} && docker compose up -d`);
  }
}

async function cmdDev(contractPath, options) {
  const { spawn } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');
  const frontendDir = path.join(outputDir, 'frontend');

  console.log('\nüì¶ Installing dependencies...');
  
  await new Promise(resolve => {
    spawn('npm', ['install'], { cwd: apiDir, stdio: 'inherit', shell: true }).on('close', resolve);
  });

  await new Promise(resolve => {
    spawn('npm', ['install'], { cwd: frontendDir, stdio: 'inherit', shell: true }).on('close', resolve);
  });

  console.log('\nüöÄ Starting development servers...\n');

  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'inherit', shell: true });
  const frontendProc = spawn('npm', ['run', 'dev'], { cwd: frontendDir, stdio: 'inherit', shell: true });

  process.on('SIGINT', () => {
    apiProc.kill();
    frontendProc.kill();
    process.exit(0);
  });
}

async function cmdRun(contractPath, options) {
  const { spawn, execSync } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');

  console.log('\nüì¶ Installing API dependencies...');
  execSync('npm install', { cwd: apiDir, stdio: 'inherit' });

  console.log('\nüöÄ Starting API server...\n');
  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'inherit', shell: true });

  await new Promise(resolve => setTimeout(resolve, 3000));

  console.log('\n‚úÖ Server running at http://localhost:8080');
  console.log('   Press Ctrl+C to stop\n');

  process.on('SIGINT', () => {
    apiProc.kill();
    process.exit(0);
  });

  await new Promise(() => {});
}

async function cmdTest(contractPath, options) {
  const { spawn, execSync } = require('child_process');
  const http = require('http');
  
  const contract = await loadContract(contractPath);
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');

  console.log('\nüì¶ Installing API dependencies...');
  execSync('npm install', { cwd: apiDir, stdio: 'pipe' });

  console.log('üöÄ Starting API server for testing...');
  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'pipe', shell: true });

  await new Promise(resolve => setTimeout(resolve, 3000));

  console.log('\nüß™ Running API tests...\n');

  const entities = contract.entities || [];
  let passed = 0, failed = 0;

  const request = (method, reqPath, body = null) => {
    return new Promise((resolve, reject) => {
      const opts = { hostname: 'localhost', port: 8080, path: reqPath, method, headers: { 'Content-Type': 'application/json' } };
      const req = http.request(opts, res => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          try { resolve({ status: res.statusCode, data: JSON.parse(data) }); }
          catch { resolve({ status: res.statusCode, data }); }
        });
      });
      req.on('error', reject);
      if (body) req.write(JSON.stringify(body));
      req.end();
    });
  };

  const test = async (name, fn) => {
    try { await fn(); console.log(`  ‚úÖ ${name}`); passed++; }
    catch (err) { console.log(`  ‚ùå ${name}: ${err.message}`); failed++; }
  };

  const assert = (cond, msg) => { if (!cond) throw new Error(msg); };

  await test('GET /api/health returns 200', async () => {
    const res = await request('GET', '/api/health');
    assert(res.status === 200, `Expected 200, got ${res.status}`);
  });

  for (const entity of entities) {
    const kebab = entity.name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    const endpoint = `/api/${kebab}s`;

    await test(`GET ${endpoint} returns 200`, async () => {
      const res = await request('GET', endpoint);
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`POST ${endpoint} creates item`, async () => {
      const res = await request('POST', endpoint, { name: `Test ${entity.name}` });
      assert(res.status === 201, `Expected 201, got ${res.status}`);
    });

    await test(`GET ${endpoint}/1 returns item`, async () => {
      const res = await request('GET', `${endpoint}/1`);
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`PUT ${endpoint}/1 updates item`, async () => {
      const res = await request('PUT', `${endpoint}/1`, { name: 'Updated' });
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`DELETE ${endpoint}/1 removes item`, async () => {
      const res = await request('DELETE', `${endpoint}/1`);
      assert(res.status === 204, `Expected 204, got ${res.status}`);
    });
  }

  apiProc.kill();
  console.log(`\nüìä Results: ${passed} passed, ${failed} failed\n`);
  if (failed > 0) process.exit(1);
}

async function cmdDeploy(contractPath, options) {
  const { execSync } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  
  // Stop any existing containers first
  console.log('\nüõë Stopping existing containers...');
  try {
    execSync('docker compose down --remove-orphans 2>/dev/null || true', { cwd: outputDir, stdio: 'pipe' });
    // Also stop any containers using our ports
    execSync('docker ps -q --filter "publish=8080" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=3000" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=5432" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
  } catch (e) { /* ignore */ }
  
  console.log('üê≥ Building Docker containers...\n');
  
  try {
    execSync('docker compose build', { cwd: outputDir, stdio: 'inherit' });
    console.log('\nüöÄ Starting containers...\n');
    execSync('docker compose up -d', { cwd: outputDir, stdio: 'inherit' });
    
    console.log('\n‚úÖ Deployment complete!');
    console.log('   API:      http://localhost:8080');
    console.log('   Frontend: http://localhost:3000');
    console.log('   Database: localhost:5432');
    console.log('\n   View logs: docker compose logs -f');
    console.log('   Stop:      docker compose down\n');
  } catch (err) {
    console.error('‚ùå Docker deployment failed. Make sure Docker is running.');
    process.exit(1);
  }
}

async function cmdValidate(contractPath) {
  console.log(`\nüîç Validating ${contractPath}...`);
  const contract = await loadContract(contractPath);
  
  const errors = [], warnings = [];
  if (!contract.app) errors.push('Missing app section');
  if (!contract.app?.name) errors.push('Missing app.name');
  if (!contract.app?.version) errors.push('Missing app.version');
  if (!contract.entities?.length) warnings.push('No entities defined');

  for (const entity of (contract.entities || [])) {
    if (!entity.name) errors.push('Entity missing name');
    if (!entity.fields?.length) warnings.push(`Entity ${entity.name} has no fields`);
  }

  if (errors.length) {
    console.log('\n‚ùå Validation failed:');
    errors.forEach(e => console.log(`  - ${e}`));
    process.exit(1);
  }

  if (warnings.length) {
    console.log('\n‚ö†Ô∏è  Warnings:');
    warnings.forEach(w => console.log(`  - ${w}`));
  }

  console.log(`\n‚úÖ Contract is valid!`);
  console.log(`   App: ${contract.app.name} v${contract.app.version}`);
  console.log(`   Entities: ${contract.entities?.length || 0}`);
  console.log(`   Events: ${contract.events?.length || 0}`);
  console.log(`   Dashboards: ${contract.dashboards?.length || 0}`);
}

async function cmdParse(contractPath) {
  const fullPath = path.resolve(contractPath);

  if (!fs.existsSync(fullPath)) {
    console.error(`‚ùå Contract file not found: ${fullPath}`);
    process.exit(1);
  }

  if (fullPath.endsWith('.contract.md')) {
    if (!parseContractMarkdown) {
      console.error('‚ùå Contract Markdown parser not available');
      process.exit(1);
    }

    const content = fs.readFileSync(fullPath, 'utf-8');
    const parsed = parseContractMarkdown(content);
    const validation = validateContractMarkdown(parsed);
    const contractAI = convertToContractAI ? convertToContractAI(parsed) : null;

    console.log(
      JSON.stringify(
        {
          path: fullPath,
          validation,
          parsed: {
            frontmatter: parsed.frontmatter,
            app: parsed.app,
            entities: parsed.entities,
            api: parsed.api,
            rules: parsed.rules,
            tech: parsed.tech,
            tests: parsed.tests
          },
          contractAI
        },
        null,
        2
      )
    );

    if (!validation.valid) {
      process.exit(1);
    }

    return;
  }

  const contract = await loadContract(contractPath);
  console.log(JSON.stringify({ path: fullPath, contract }, null, 2));
}

async function cmdConvert(inputPath, options = {}) {
  const fullInput = path.resolve(inputPath);
  if (!fs.existsSync(fullInput)) {
    console.error(`‚ùå Input file not found: ${fullInput}`);
    process.exit(1);
  }

  const targetFormat = options.format || 'md';
  console.log(`\nüîÑ Converting ${inputPath} to ${targetFormat}...`);

  // Load source contract
  let ir;
  
  if (fullInput.endsWith('.rcl.md') || fullInput.endsWith('.md')) {
    // From Markdown
    if (!parseMarkdownFile) {
      console.error('‚ùå Markdown parser not available');
      process.exit(1);
    }
    const result = parseMarkdownFile(fullInput);
    if (!result.success) {
      console.error('‚ùå Parse error:', result.errors[0]?.message);
      process.exit(1);
    }
    ir = result.ir;
  } else if (fullInput.endsWith('.rcl')) {
    // From Mini-DSL
    if (!parseMiniFile) {
      console.error('‚ùå Mini-DSL parser not available');
      process.exit(1);
    }
    const result = parseMiniFile(fullInput);
    if (!result.success) {
      console.error('‚ùå Parse error:', result.errors[0]?.message);
      process.exit(1);
    }
    ir = miniToIR(result.ast);
  } else if (fullInput.endsWith('.ts')) {
    // From TypeScript
    delete require.cache[require.resolve(fullInput)];
    const mod = require(fullInput);
    const contract = mod.contract || mod.default || mod;
    ir = {
      app: contract.app,
      entities: contract.entities || [],
      enums: contract.enums || [],
      events: contract.events || [],
      pipelines: contract.pipelines || [],
      alerts: contract.alerts || [],
      dashboards: contract.dashboards || [],
      sources: contract.sources || [],
      workflows: contract.workflows || [],
      config: contract.config || {},
      env: contract.env || []
    };
  } else {
    console.error('‚ùå Unknown input format. Use .rcl, .rcl.md, or .ts');
    process.exit(1);
  }

  // Convert to target format
  let output, outPath;

  switch (targetFormat) {
    case 'md':
    case 'markdown':
      if (!writeMarkdownContract) {
        console.error('‚ùå Markdown writer not available');
        process.exit(1);
      }
      output = writeMarkdownContract(ir, [], { includeConversation: false });
      outPath = options.output || inputPath.replace(/\.(reclapp\.ts|reclapp\.rcl|rcl|ts)$/, '.rcl.md');
      break;

    case 'ts':
    case 'typescript':
      output = generateTypeScriptContract(ir);
      outPath = options.output || inputPath.replace(/\.(rcl\.md|rcl|md)$/, '.reclapp.ts');
      break;

    case 'rcl':
    case 'mini':
      if (!irToMini) {
        console.error('‚ùå Mini-DSL writer not available');
        process.exit(1);
      }
      output = irToMini(ir);
      outPath = options.output || inputPath.replace(/\.(rcl\.md|reclapp\.ts|ts|md)$/, '.reclapp.rcl');
      break;

    default:
      console.error(`‚ùå Unknown target format: ${targetFormat}. Use md, ts, or rcl`);
      process.exit(1);
  }

  fs.writeFileSync(outPath, output);
  console.log(`‚úÖ Converted to ${outPath}`);
}

async function cmdNormalize(inputPath, options = {}) {
  if (!normalizeMiniRclSource) {
    console.error('‚ùå Normalization not available');
    process.exit(1);
  }

  const fullInput = path.resolve(inputPath);
  if (!fs.existsSync(fullInput)) {
    console.error(`‚ùå Input file not found: ${fullInput}`);
    process.exit(1);
  }

  const inPlace = !!options.inPlace;
  const outPath = inPlace
    ? fullInput
    : (options.output || inputPath.replace(/\.rcl(\.md)?$/, '.reclapp.rcl'));

  const source = fs.readFileSync(fullInput, 'utf-8');
  const normalized = normalizeMiniRclSource(source);

  fs.writeFileSync(outPath, normalized);
  console.log(`‚úÖ Normalized: ${outPath}`);
}

function generateTypeScriptContract(ir) {
  const lines = [
    '// Generated from Mini-DSL contract',
    `// App: ${ir.app?.name || 'Unknown'}`,
    '',
    'export const contract = {',
    `  app: ${JSON.stringify(ir.app, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  entities: ${JSON.stringify(ir.entities, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  events: ${JSON.stringify(ir.events, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  pipelines: ${JSON.stringify(ir.pipelines, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  alerts: ${JSON.stringify(ir.alerts, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  dashboards: ${JSON.stringify(ir.dashboards, null, 4).replace(/\n/g, '\n  ')},`,
    '};',
    ''
  ];
  return lines.join('\n');
}

async function cmdList() {
  const { ShellRenderer } = require('../src/core/contract-ai/evolution/shell-renderer');
  const renderer = new ShellRenderer();
  
  renderer.heading(2, 'üìã Available Contracts');
  
  const findContracts = (dir, prefix = '') => {
    if (!fs.existsSync(dir)) return [];
    const results = [];
    for (const item of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules' && item !== 'target') {
        results.push(...findContracts(fullPath, path.join(prefix, item)));
      } else if (item.endsWith('.reclapp.ts') || item.endsWith('.reclapp.rcl') || item.endsWith('.rcl.md')) {
        results.push(path.join(prefix, item));
      }
    }
    return results;
  };

  const contracts = findContracts(process.cwd());
  if (contracts.length === 0) {
    renderer.codeblock('log', '‚ö†Ô∏è No contracts found (.reclapp.ts, .reclapp.rcl, or .rcl.md)');
  } else {
    const tsContracts = contracts.filter(c => c.endsWith('.ts'));
    const rclContracts = contracts.filter(c => c.endsWith('.rcl') && !c.endsWith('.rcl.md'));
    const mdContracts = contracts.filter(c => c.endsWith('.rcl.md'));
    
    const data = {
      total: contracts.length,
      formats: {}
    };
    
    if (tsContracts.length) data.formats['TypeScript (.reclapp.ts)'] = tsContracts;
    if (rclContracts.length) data.formats['Mini-DSL (.reclapp.rcl)'] = rclContracts;
    if (mdContracts.length) data.formats['Markdown (.rcl.md)'] = mdContracts;
    
    renderer.codeblock('yaml', `# @type: contracts\n# @description: Available contract files\ntotal: ${contracts.length}\nformats:\n${
      Object.entries(data.formats).map(([fmt, files]) => 
        `  "${fmt}":\n${files.map(f => `    - "${f}"`).join('\n')}`
      ).join('\n')
    }`);
  }
}

async function cmdStop() {
  const { execSync } = require('child_process');
  const { ShellRenderer } = require('../src/core/contract-ai/evolution/shell-renderer');
  const renderer = new ShellRenderer();
  
  renderer.heading(2, 'üõë Stopping Reclapp Containers');
  
  try {
    // Stop containers on common ports
    execSync('docker ps -q --filter "publish=8080" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=3000" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=5432" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    
    // Stop target containers by name
    execSync('docker ps -q --filter "name=target" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    
    renderer.codeblock('log', '‚úÖ All containers stopped.');
  } catch (e) {
    renderer.codeblock('log', '‚úÖ No running containers found.');
  }
}

async function cmdChat() {
  // Launch the interactive chat CLI
  const { spawn } = require('child_process');
  const chatPath = path.join(__dirname, 'reclapp-chat');
  
  if (!fs.existsSync(chatPath)) {
    console.error('‚ùå Chat module not found. Run from project root.');
    process.exit(1);
  }
  
  const child = spawn('node', [chatPath], {
    stdio: 'inherit',
    cwd: process.cwd()
  });
  
  child.on('close', (code) => process.exit(code));
}

async function cmdGenerateAI(args, options) {
  // Parse generate-ai specific arguments
  let contractFile = null;
  let prompt = null;
  let dryRun = false;
  let maxIterations = 10;
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--prompt' || arg === '-p') {
      prompt = args[++i];
    } else if (arg === '--dry-run') {
      dryRun = true;
    } else if (arg === '--max-iterations') {
      maxIterations = parseInt(args[++i], 10);
    } else if (arg === '--output' || arg === '-o') {
      // Skip -o and its value (handled by main options)
      i++;
    } else if (!arg.startsWith('-') && !contractFile) {
      contractFile = arg;
    }
  }

  console.log('\nü§ñ Reclapp Contract AI Generator v2.2.0\n');

  try {
    // Dynamic import of contract-ai module
    const contractAI = require('../src/core/contract-ai');

    let contract;

    if (contractFile) {
      console.log(`üìÑ Loading contract from: ${contractFile}`);
      
      // Load ContractAI file directly (bypasses loadContract which expects app at root)
      const fullPath = path.resolve(contractFile);
      if (!fs.existsSync(fullPath)) {
        console.error(`‚ùå Contract file not found: ${fullPath}`);
        process.exit(1);
      }
      
      delete require.cache[require.resolve(fullPath)];
      const module = require(fullPath);
      // Try various export names for Contract AI files
      contract = module.crmContract || 
                 module.taskManagerContract || 
                 module.ecommerceContract || 
                 module.blogContract ||
                 module.contract || 
                 module.default || 
                 // Find first ContractAI-like export
                 Object.values(module).find(v => v && typeof v === 'object' && v.definition) ||
                 module;
      
      // Convert old format to Contract AI format if needed
      if (!contract.definition && contract.app) {
        contract = {
          definition: {
            app: contract.app,
            entities: contract.entities || [],
            events: contract.events || [],
            api: contract.api
          },
          generation: {
            instructions: [
              { target: 'api', priority: 'must', instruction: 'Use Express.js with TypeScript' }
            ],
            patterns: [],
            constraints: [],
            techStack: {
              backend: { runtime: 'node', language: 'typescript', framework: 'express', port: 8080 }
            }
          },
          validation: {
            assertions: [],
            tests: [],
            staticRules: [],
            qualityGates: [{ name: 'Coverage', metric: 'test-coverage', threshold: 70, operator: '>=' }],
            acceptance: { testsPass: true, minCoverage: 70, maxLintErrors: 0, maxResponseTime: 500, securityChecks: [], custom: [] }
          }
        };
      }
    } else if (prompt) {
      console.log(`üí¨ Generating contract from prompt: "${prompt}"`);
      
      const generator = contractAI.createContractGenerator({
        verbose: options.verbose,
        maxAttempts: maxIterations
      });

      const result = await generator.generate(prompt);
      
      if (!result.success) {
        console.error('‚ùå Failed to generate contract');
        result.errors.forEach(e => console.error(`   - ${e.message}`));
        process.exit(1);
      }

      contract = result.contract;
      console.log(`‚úÖ Contract generated in ${result.attempts} attempt(s)`);
    } else {
      console.error('‚ùå Provide either a contract file or --prompt');
      console.log('\nUsage:');
      console.log('  reclapp generate-ai <contract-file>');
      console.log('  reclapp generate-ai --prompt "Create a CRM system"');
      process.exit(1);
    }

    // Validate contract
    const validator = contractAI.createContractValidator();
    const validationResult = validator.validate(contract);

    if (!validationResult.valid) {
      console.error('‚ùå Contract validation failed:');
      validationResult.errors.slice(0, 5).forEach(e => 
        console.error(`   - [${e.code}] ${e.path}: ${e.message}`)
      );
      process.exit(1);
    }

    console.log('‚úÖ Contract validated successfully');

    if (dryRun) {
      console.log('\nüìã Contract (dry-run):');
      console.log(JSON.stringify(contract, null, 2));
      return;
    }

    // Generate code
    console.log('\nüî® Generating code...');
    
    const codeGenerator = contractAI.createLLMCodeGenerator({
      verbose: options.verbose
    });

    // Check for Ollama availability
    let llmMode = 'simulated';
    try {
      const ollamaAvailable = await contractAI.checkOllamaAvailable();
      if (ollamaAvailable) {
        const selectedModel = process.env.CODE_MODEL || process.env.OLLAMA_MODEL;
        const selectedFrom = process.env.CODE_MODEL ? 'CODE_MODEL' : 'OLLAMA_MODEL';
        const ollamaClient = contractAI.createOllamaClient({ model: selectedModel });
        const hasModel = await ollamaClient.hasModel();
        if (hasModel) {
          codeGenerator.setLLMClient(ollamaClient);
          llmMode = ollamaClient.getConfig().model;
          console.log(`ü§ñ Using Ollama (${llmMode}) for code generation`);
        } else {
          const model = ollamaClient.getConfig().model;
          console.log(`‚ö†Ô∏è Ollama model '${model}' not found (from ${selectedFrom})`);
          console.log(`   Fix: ollama pull ${model}`);
          console.log(`   Or update .env: ${selectedFrom}=<installed_model>`);
          console.log('   Using simulation mode');
        }
      } else {
        console.log('‚ö†Ô∏è Ollama not available. Using simulation mode');
      }
    } catch (err) {
      // Silently fall back to simulation
    }

    const generatedCode = await codeGenerator.generate(contract);
    
    console.log(`‚úÖ Generated ${generatedCode.files.length} files`);

    // Run validation pipeline
    console.log('\nüîç Running validation pipeline...');
    
    const pipeline = contractAI.createDefaultValidationPipeline();
    const pipelineResult = await pipeline.validate(contract, generatedCode);

    if (pipelineResult.passed) {
      console.log('‚úÖ All validation stages passed');
    } else {
      console.log(`‚ö†Ô∏è Validation: ${pipelineResult.summary.passedStages}/${pipelineResult.stages.length} stages passed`);
    }

    // Write output files
    const outputDir = options.output || './generated';
    console.log(`\nüìÅ Writing files to: ${outputDir}`);
    
    for (const file of generatedCode.files) {
      const filePath = path.join(outputDir, file.path);
      const fileDir = path.dirname(filePath);
      if (!fs.existsSync(fileDir)) {
        fs.mkdirSync(fileDir, { recursive: true });
      }
      fs.writeFileSync(filePath, file.content, 'utf-8');
    }

    // Generate .rcl.md log
    const logsDir = path.join(outputDir, 'logs');
    try {
      const logWriter = contractAI.createGenerationLogWriter({ outputDir: logsDir });
      const logPath = logWriter.writeLog({
        timestamp: new Date(),
        contract,
        generatedCode,
        pipelineResult,
        model: llmMode
      });
      console.log(`\nüìù Log saved: ${logPath}`);
    } catch (logError) {
      // Log generation is optional, don't fail on error
    }

    console.log('\n' + '‚ïê'.repeat(50));
    console.log('‚ú® Generation complete!');
    console.log('‚ïê'.repeat(50));
    console.log(`   Files: ${generatedCode.files.length}`);
    console.log(`   Output: ${outputDir}`);

  } catch (error) {
    console.error(`\n‚ùå Error: ${error.message}`);
    if (options.verbose) console.error(error.stack);
    process.exit(1);
  }
}

async function cmdStudio() {
  const readline = require('readline');
  const { execSync } = require('child_process');
  
  const findContracts = (dir, prefix = '') => {
    if (!fs.existsSync(dir)) return [];
    const results = [];
    for (const item of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules' && item !== 'target') {
        results.push(...findContracts(fullPath, path.join(prefix, item)));
      } else if (item.endsWith('.reclapp.ts') || item.endsWith('.reclapp.rcl') || item.endsWith('.rcl.md')) {
        results.push({ path: path.join(prefix, item), full: fullPath });
      }
    }
    return results;
  };

  const contracts = findContracts(process.cwd());
  
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üöÄ RECLAPP STUDIO                         ‚ïë
‚ïë        Interactive Examples Browser (TS + RCL + MD)          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

  if (contracts.length === 0) {
    console.log('  No contracts found (.reclapp.ts, .reclapp.rcl, or .rcl.md)\n');
    return;
  }

  // Load contract info
  const examples = [];
  for (const c of contracts) {
    try {
      let contract;
      if (c.full.endsWith('.rcl.md')) {
        // Load Markdown file
        if (parseMarkdownFile) {
          const result = parseMarkdownFile(c.full);
          if (result.success) {
            contract = irToContract(result.ir);
          } else {
            throw new Error('Parse error');
          }
        } else {
          throw new Error('Markdown parser not available');
        }
      } else if (c.full.endsWith('.rcl')) {
        // Load RCL file
        if (parseMiniFile) {
          const result = parseMiniFile(c.full);
          if (result.success) {
            const ir = miniToIR(result.ast);
            contract = { app: ir.app, entities: ir.entities, events: ir.events };
          } else {
            throw new Error('Parse error');
          }
        } else {
          throw new Error('Parser not available');
        }
      } else {
        // Load TS file
        delete require.cache[require.resolve(c.full)];
        const mod = require(c.full);
        contract = mod.contract || mod.default || mod;
      }
      let ext = '.reclapp.ts';
      let format = 'ts';
      if (c.full.endsWith('.rcl.md')) { ext = '.rcl.md'; format = 'md'; }
      else if (c.full.endsWith('.rcl')) { ext = '.reclapp.rcl'; format = 'rcl'; }
      examples.push({
        path: c.path,
        full: c.full,
        name: contract.app?.name || path.basename(c.path, ext),
        version: contract.app?.version || '1.0.0',
        description: contract.app?.description || '',
        entities: contract.entities?.length || 0,
        events: contract.events?.length || 0,
        format
      });
    } catch (e) {
      examples.push({ path: c.path, full: c.full, name: path.basename(c.path), error: true });
    }
  }

  console.log('Available Examples:\n');
  examples.forEach((ex, i) => {
    if (ex.error) {
      console.log(`  ${i + 1}. ‚ùå ${ex.path} (invalid contract)`);
    } else {
      console.log(`  ${i + 1}. ${ex.name} v${ex.version}`);
      console.log(`     ${ex.description || 'No description'}`);
      console.log(`     üì¶ ${ex.entities} entities, ${ex.events} events`);
      console.log(`     üìÑ ${ex.path}\n`);
    }
  });

  console.log(`
Commands:
  [1-${examples.length}]  Select example
  g <n>    Generate example
  t <n>    Test example
  d <n>    Deploy example
  s        Stop all containers
  q        Quit
`);

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  
  const prompt = () => {
    rl.question('studio> ', async (answer) => {
      const parts = answer.trim().split(/\s+/);
      const cmd = parts[0];
      const num = parseInt(parts[1] || parts[0]) - 1;
      
      if (cmd === 'q' || cmd === 'quit' || cmd === 'exit') {
        console.log('\nüëã Goodbye!\n');
        rl.close();
        return;
      }
      
      if (cmd === 's' || cmd === 'stop') {
        await cmdStop();
        prompt();
        return;
      }
      
      if ((cmd === 'g' || cmd === 'generate') && num >= 0 && num < examples.length) {
        await cmdGenerate(examples[num].full, { verbose: true });
        prompt();
        return;
      }
      
      if ((cmd === 't' || cmd === 'test') && num >= 0 && num < examples.length) {
        await cmdTest(examples[num].full, {});
        prompt();
        return;
      }
      
      if ((cmd === 'd' || cmd === 'deploy') && num >= 0 && num < examples.length) {
        await cmdDeploy(examples[num].full, {});
        prompt();
        return;
      }
      
      // Direct number selection - show menu
      if (!isNaN(parseInt(cmd)) && parseInt(cmd) >= 1 && parseInt(cmd) <= examples.length) {
        const ex = examples[parseInt(cmd) - 1];
        console.log(`\n  Selected: ${ex.name}\n`);
        console.log(`  Actions:`);
        console.log(`    g ${cmd}  - Generate`);
        console.log(`    t ${cmd}  - Test`);
        console.log(`    d ${cmd}  - Deploy\n`);
      }
      
      prompt();
    });
  };
  
  prompt();
}

// ============================================================================
// ANALYZE COMMAND
// ============================================================================

async function cmdAnalyze(args, options) {
  const targetDir = args[0] || '.';
  const outputJson = args.includes('--json');
  const outputContract = args.includes('--contract');

  console.log(`\nüìä Analyzing: ${path.resolve(targetDir)}\n`);

  try {
    const { CodeAnalyzer } = require('../src/core/contract-ai/analysis/code-analyzer');
    const analyzer = new CodeAnalyzer(targetDir);
    const report = await analyzer.analyze();

    if (outputJson) {
      console.log(JSON.stringify(report, (key, value) => {
        if (value instanceof Map) return Object.fromEntries(value);
        return value;
      }, 2));
    } else if (outputContract) {
      const contract = analyzer.toContract(report);
      console.log(JSON.stringify(contract, null, 2));
    } else {
      console.log(analyzer.toMarkdown(report));
    }

    // Save report
    const reportsDir = path.join(targetDir, 'reports');
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    const reportPath = path.join(reportsDir, `analysis-${Date.now()}.md`);
    fs.writeFileSync(reportPath, analyzer.toMarkdown(report), 'utf-8');
    console.log(`\nüìù Report saved: ${reportPath}`);
  } catch (e) {
    console.error(`‚ùå Analysis failed: ${e.message}`);
    process.exit(1);
  }
}

async function cmdReverse(args, options) {
  const targetDir = args[0] || '.';
  const outPath = options.output || path.join(process.cwd(), 'reverse-engineered.rcl.md');

  console.log(`\nüîÑ Reverse engineering from: ${path.resolve(targetDir)}`);

  try {
    const { CodeAnalyzer } = require('../src/core/contract-ai/analysis/code-analyzer');
    const { writeMarkdownContract, contractToIR } = require('../dsl/writer/markdown');

    // Prefer the saved original contract (generated during `reclapp generate/run`)
    const contractPaths = [
      path.join(targetDir, 'contract', 'contract.ai.json'),
      path.join(targetDir, 'contract.ai.json'),
      path.join(path.dirname(targetDir), 'contract', 'contract.ai.json')
    ];

    let baseContract = null;
    for (const p of contractPaths) {
      if (!fs.existsSync(p)) continue;
      try {
        baseContract = JSON.parse(fs.readFileSync(p, 'utf-8'));
        console.log(`‚ÑπÔ∏è  Found saved contract: ${p}`);
        break;
      } catch (e) {
        console.warn(`‚ö†Ô∏è  Failed to parse saved contract at ${p}: ${e.message}`);
      }
    }

    const analyzer = new CodeAnalyzer(targetDir);
    const report = await analyzer.analyze();
    const derived = analyzer.toContract(report);

    // If we found the saved contract, use it as source of truth and only merge in
    // potentially useful details from analysis (e.g. api prefix/port differences).
    let contract = baseContract || derived;
    if (baseContract) {
      contract = analyzer.mergeWithAIPlan(derived, baseContract);
    }

    // Convert contract to IR and then to Markdown
    const ir = contractToIR(contract);
    const markdown = writeMarkdownContract(ir, [], { includeConversation: false });

    // Ensure directory exists
    const outDir = path.dirname(outPath);
    if (!fs.existsSync(outDir)) {
      fs.mkdirSync(outDir, { recursive: true });
    }

    fs.writeFileSync(outPath, markdown, 'utf-8');
    console.log(`\n‚úÖ Contract generated: ${outPath}`);

  } catch (e) {
    console.error(`‚ùå Reverse engineering failed: ${e.message}`);
    if (options.verbose) console.error(e.stack);
    process.exit(1);
  }
}

// ============================================================================
// REFACTOR COMMAND
// ============================================================================

async function cmdRefactor(args, options) {
  const { execSync } = require('child_process');
  const target = args[0];
  
  if (!target) {
    console.error('‚ùå Missing target (git URL or directory)');
    process.exit(1);
  }

  let workDir = target;
  let repoUrl = target;

  // Check if it's a git URL
  if (target.startsWith('http') || target.startsWith('git@') || target.includes('github.com')) {
    const repoName = target.split('/').pop()?.replace('.git', '') || 'repo';
    workDir = path.join(options.output || './refactor-workspace', repoName);

    console.log(`\nüì¶ Cloning ${target}...`);
    if (fs.existsSync(workDir)) {
      console.log(`   Directory exists, pulling latest...`);
      execSync('git pull', { cwd: workDir, stdio: 'inherit' });
    } else {
      execSync(`git clone ${target} ${workDir}`, { stdio: 'inherit' });
    }
  } else {
    repoUrl = undefined;
  }

  console.log(`\nüìä Analyzing ${workDir}...`);

  try {
    const { CodeAnalyzer } = require('../src/core/contract-ai/analysis/code-analyzer');
    const { RefactoringContractGenerator } = require('../src/core/contract-ai/analysis/refactoring-contract');
    const { ProjectStateGenerator } = require('../src/core/contract-ai/analysis/project-state');
    
    const analyzer = new CodeAnalyzer(workDir);
    const report = await analyzer.analyze();

    // Generate project state (source of knowledge about current state)
    const stateGen = new ProjectStateGenerator(report, workDir);
    const projectState = stateGen.generate();

    // Generate refactoring contract
    const contractGen = new RefactoringContractGenerator(report, repoUrl);
    const refactoringContract = contractGen.generate();
    
    // Save outputs
    const contractDir = path.join(workDir, 'contract');
    if (!fs.existsSync(contractDir)) {
      fs.mkdirSync(contractDir, { recursive: true });
    }

    // 1. JSON contract (machine-readable)
    const jsonPath = path.join(contractDir, 'refactoring_contract.json');
    fs.writeFileSync(jsonPath, contractGen.toJSON(), 'utf-8');

    // 2. Markdown report (human-readable)
    const mdPath = path.join(contractDir, 'analysis_report.md');
    fs.writeFileSync(mdPath, contractGen.toMarkdown(), 'utf-8');

    // 3. TODO list (actionable)
    const todoPath = path.join(contractDir, 'todo_list.md');
    fs.writeFileSync(todoPath, contractGen.toTodoList(), 'utf-8');

    // 4. Original analysis
    const analysisPath = path.join(contractDir, 'code_analysis.md');
    fs.writeFileSync(analysisPath, analyzer.toMarkdown(report), 'utf-8');

    // 5. Project state (source of knowledge about current state)
    const stateDir = path.join(workDir, 'state');
    if (!fs.existsSync(stateDir)) {
      fs.mkdirSync(stateDir, { recursive: true });
    }
    const statePath = path.join(stateDir, 'project-state.json');
    fs.writeFileSync(statePath, JSON.stringify(projectState, null, 2), 'utf-8');

    // 6. LLM summary (for small context windows)
    const summaryPath = path.join(stateDir, 'llm-summary.md');
    fs.writeFileSync(summaryPath, stateGen.toLLMSummary(), 'utf-8');

    console.log('\n‚úÖ Refactoring contract generated!\n');
    console.log('Output files:');
    console.log(`  - ${jsonPath}`);
    console.log(`  - ${mdPath}`);
    console.log(`  - ${todoPath}`);
    console.log(`  - ${analysisPath}`);
    console.log(`  - ${statePath} (project state)`);
    console.log(`  - ${summaryPath} (LLM summary)`);

    console.log('\n## Summary\n');
    console.log(`Files: ${report.summary.totalFiles}`);
    console.log(`Functions: ${report.summary.totalFunctions}`);
    console.log(`Issues: ${refactoringContract.summary.total_issues}`);
    console.log(`  - Critical: ${refactoringContract.summary.by_severity.critical}`);
    console.log(`  - High: ${refactoringContract.summary.by_severity.high}`);
    console.log(`  - Medium: ${refactoringContract.summary.by_severity.medium}`);
    console.log(`  - Low: ${refactoringContract.summary.by_severity.low}`);
    console.log(`Total Effort: ${refactoringContract.summary.total_effort_days} days`);

    if (refactoringContract.issues.length > 0) {
      console.log('\n## Top Issues\n');
      for (const issue of refactoringContract.issues.slice(0, 5)) {
        console.log(`- [${issue.severity.toUpperCase()}] ${issue.function} (${issue.file}:${issue.line})`);
        console.log(`  Action: ${issue.type}, Effort: ${issue.effort}d`);
      }
    }

    if (refactoringContract.recommendations.length > 0) {
      console.log('\n## Recommendations\n');
      for (const rec of refactoringContract.recommendations.slice(0, 5)) {
        console.log(`- ${rec}`);
      }
    }
  } catch (e) {
    console.error(`‚ùå Refactor analysis failed: ${e.message}`);
    process.exit(1);
  }
}

// ============================================================================
// EVOLUTION COMMAND
// ============================================================================

async function cmdEvolution(args, options) {
  const readline = require('readline');

  const maxBackticks = (s) => {
    let max = 0;
    let cur = 0;
    for (let i = 0; i < s.length; i++) {
      if (s[i] === '`') {
        cur++;
        if (cur > max) max = cur;
      } else {
        cur = 0;
      }
    }
    return max;
  };

  const getFence = (content) => '`'.repeat(Math.max(3, maxBackticks(content) + 1));

  const printFencedBlock = (content, lang) => {
    const safe = (content ?? '').toString().replace(/\s+$/, '');
    const fence = getFence(safe);
    console.log(`${fence}${lang ? lang : ''}`);
    console.log(safe);
    console.log(fence);
  };

  const fencedBlockString = (content, lang) => {
    const safe = (content ?? '').toString().replace(/\s+$/, '');
    const fence = getFence(safe);
    return `${fence}${lang ? lang : ''}\n${safe}\n${fence}\n`;
  };

  const renderMarkdownWithFences = (renderer, markdownText) => {
    const lines = (markdownText ?? '').toString().split('\n');
    let inFence = false;
    let fence = '```';
    let lang = 'text';
    let buf = [];

    const flush = () => {
      if (!inFence) return;
      const langNormalized = (lang || 'text').split(':')[0].trim() || 'text';
      renderer.codeblock(langNormalized, buf.join('\n'));
      inFence = false;
      fence = '```';
      lang = 'text';
      buf = [];
    };

    for (const line of lines) {
      const trimmed = line.trimEnd();
      const m = trimmed.match(/^(`{3,})(.*)$/);
      if (!inFence) {
        if (m) {
          inFence = true;
          fence = m[1];
          lang = (m[2] || '').trim();
          buf = [];
        } else {
          console.log(line);
        }
      } else {
        if (trimmed.trim() === fence) {
          flush();
        } else {
          buf.push(line);
        }
      }
    }

    flush();
  };

  // Parse evolution-specific options
  let prompt = null;
  let contractPath = null;
  let outputDir = options.output || './generated';
  let port = 3000;
  let keepRunning = false;
  let noMenu = false;
  let logFile = null;

  for (let i = 0; i < args.length; i++) {
    if ((args[i] === '--prompt' || args[i] === '-p') && args[i + 1]) {
      prompt = args[i + 1]; i++;
    } else if ((args[i] === '--output' || args[i] === '-o') && args[i + 1]) {
      outputDir = args[i + 1]; i++;
    } else if (args[i] === '--port' && args[i + 1]) {
      port = parseInt(args[i + 1]); i++;
    } else if (args[i] === '--keep-running' || args[i] === '-k') {
      keepRunning = true;
    } else if (args[i] === '--no-menu') {
      noMenu = true;
    } else if (args[i] === '--log-file' && args[i + 1]) {
      logFile = args[i + 1]; i++;
    } else if (!args[i].startsWith('-')) {
      contractPath = args[i];
    }
  }

  if (!prompt && !contractPath) {
    console.error('‚ùå Usage: reclapp evolve --prompt "..." [-o <dir>] [--no-menu] [--log-file <path>]');
    console.error('           reclapp evolve <contract.ts> [-o <dir>] [--no-menu] [--log-file <path>]');
    process.exit(1);
  }

  console.log('\n## Reclapp Evolution v2.4.1\n');

  try {
    const contractAI = require('../src/core/contract-ai');
    const verbose = true;
    const extraVerbose = !!(options && options.verbose === true);
    const startupTimeoutMs = parseInt(process.env.RECLAPP_EVOLVE_STARTUP_TIMEOUT_MS || '2000', 10);
    const llmTimeoutMs = parseInt(process.env.RECLAPP_LLM_TIMEOUT_MS || '60000', 10);
    const llmHeartbeatMs = parseInt(process.env.RECLAPP_LLM_HEARTBEAT_MS || '2000', 10);

    let logStream = null;
    let restoreStdout = null;
    let restoreStderr = null;
    const cleanupLogging = () => {
      if (restoreStdout) {
        try { restoreStdout(); } catch (e) {}
        restoreStdout = null;
      }
      if (restoreStderr) {
        try { restoreStderr(); } catch (e) {}
        restoreStderr = null;
      }
      if (logStream) {
        try { logStream.end(); } catch (e) {}
        logStream = null;
      }
    };

    process.on('exit', cleanupLogging);

    if (logFile) {
      try {
        const logPath = path.resolve(logFile);
        fs.mkdirSync(path.dirname(logPath), { recursive: true });
        logStream = fs.createWriteStream(logPath, { flags: 'a' });

        const stripAnsi = (s) => (s || '').replace(/\x1b\[[0-9;]*m/g, '');

        const origStdoutWrite = process.stdout.write.bind(process.stdout);
        const origStderrWrite = process.stderr.write.bind(process.stderr);

        process.stdout.write = (chunk, encoding, cb) => {
          try {
            const text = Buffer.isBuffer(chunk) ? chunk.toString(typeof encoding === 'string' ? encoding : 'utf8') : String(chunk);
            logStream.write(stripAnsi(text));
          } catch (e) {}
          return origStdoutWrite(chunk, encoding, cb);
        };

        process.stderr.write = (chunk, encoding, cb) => {
          try {
            const text = Buffer.isBuffer(chunk) ? chunk.toString(typeof encoding === 'string' ? encoding : 'utf8') : String(chunk);
            logStream.write(stripAnsi(text));
          } catch (e) {}
          return origStderrWrite(chunk, encoding, cb);
        };

        restoreStdout = () => { process.stdout.write = origStdoutWrite; };
        restoreStderr = () => { process.stderr.write = origStderrWrite; };
      } catch (e) {
        logFile = null;
        cleanupLogging();
      }
    }

    const { ShellRenderer } = contractAI;
    const cliRenderer = new ShellRenderer(true);
    
    // Create evolution manager
    const evolutionManager = contractAI.createEvolutionManager({
      outputDir,
      port,
      verbose,
      maxEvolutionCycles: 10,
      autoRestart: true
    });

    // Setup LLM routing for evolution (multi-provider)
    let llmStatus = { available: false, provider: null, model: null };
    let llmDebugLines = [];
    try {
      const { createLLMManagerFromEnv } = contractAI;
      const llmManager = createLLMManagerFromEnv();
      const statuses = await llmManager.checkAvailability();
      if (Array.isArray(statuses)) {
        llmDebugLines = statuses.map(s => `- ${s.provider}: available=${s.available} model=${s.model || 'n/a'} latencyMs=${s.latencyMs || 'n/a'}`);
      }
      const best = llmManager.getBestProvider({ type: 'code', complexity: 'high', tokensRequired: 12000 });

      if (best) {
        // Adapter from multi-provider API (ILLMProvider/LLMManager) to legacy LLMClient interface
        const llmClient = {
          generate: async ({ system, user, temperature, maxTokens }) => {
            const callId = `llm_${Date.now().toString(36)}_${Math.random().toString(16).slice(2, 8)}`;
            const startedAt = Date.now();
            let heartbeatTimer = null;
            let timeoutTimer = null;

            try {
              cliRenderer.codeblock('log', `‚Üí LLM call started (${callId}) provider=${llmStatus.provider || 'auto'} model=${llmStatus.model || 'default'} timeoutMs=${llmTimeoutMs}`);

              if (extraVerbose) {
                cliRenderer.codeblock('yaml', [
                  '# @type: llm_call_start',
                  '# @description: LLM call started',
                  'llm_call:',
                  `  id: "${callId}"`,
                  `  provider_env: "${process.env.LLM_PROVIDER || 'auto'}"`,
                  `  resolved_provider: "${llmStatus.provider || 'unknown'}"`,
                  `  resolved_model: "${llmStatus.model || 'unknown'}"`,
                  `  timeout_ms: ${llmTimeoutMs}`,
                  `  heartbeat_ms: ${llmHeartbeatMs}`
                ].join('\n'));

                heartbeatTimer = setInterval(() => {
                  const elapsedMs = Date.now() - startedAt;
                  cliRenderer.codeblock('log', `‚Ä¶ waiting for LLM (${callId}) elapsed=${Math.round(elapsedMs / 1000)}s`);
                }, llmHeartbeatMs);
              }

              const timeoutPromise = new Promise((_, reject) => {
                timeoutTimer = setTimeout(() => {
                  reject(new Error(`LLM request timeout after ${llmTimeoutMs}ms (${callId})`));
                }, llmTimeoutMs);
              });

              const chatPromise = llmManager.chat(
                [
                  { role: 'system', content: system },
                  { role: 'user', content: user }
                ],
                { type: 'code', complexity: 'high', tokensRequired: 12000 },
                {
                  temperature,
                  maxTokens,
                  timeout: llmTimeoutMs
                }
              );

              const response = await Promise.race([chatPromise, timeoutPromise]);

              if (extraVerbose) {
                const elapsedMs = Date.now() - startedAt;
                cliRenderer.codeblock('yaml', [
                  '# @type: llm_call_done',
                  '# @description: LLM call finished',
                  'llm_call:',
                  `  id: "${callId}"`,
                  `  status: "ok"`,
                  `  provider: "${response.provider}"`,
                  `  model: "${response.model}"`,
                  `  latency_ms: ${response.latencyMs || 'n/a'}`,
                  `  elapsed_ms: ${elapsedMs}`
                ].join('\n'));
              }

              return response.content;
            } catch (e) {
              if (extraVerbose) {
                const elapsedMs = Date.now() - startedAt;
                cliRenderer.codeblock('yaml', [
                  '# @type: llm_call_error',
                  '# @description: LLM call failed',
                  'llm_call:',
                  `  id: "${callId}"`,
                  `  status: "error"`,
                  `  elapsed_ms: ${elapsedMs}`,
                  `  error: "${(e && e.message) ? String(e.message).replace(/\n/g, ' ') : 'unknown'}"`
                ].join('\n'));
              }
              throw e;
            } finally {
              if (heartbeatTimer) {
                try { clearInterval(heartbeatTimer); } catch (e) {}
              }
              if (timeoutTimer) {
                try { clearTimeout(timeoutTimer); } catch (e) {}
              }
            }
          }
        };

        evolutionManager.setLLMClient(llmClient);

        // Determine a friendly status line (use env model for provider)
        const selectedProvider = process.env.LLM_PROVIDER || 'auto';
        const providerForStatus = (selectedProvider === 'auto') ? best.type : selectedProvider;
        const modelForStatus =
          (providerForStatus === 'openrouter') ? (process.env.OPENROUTER_MODEL || 'openrouter') :
          (providerForStatus === 'litellm') ? (process.env.LITELLM_MODEL || 'litellm') :
          (providerForStatus === 'windsurf') ? (process.env.WINDSURF_MODEL || 'windsurf') :
          (providerForStatus === 'ollama') ? (process.env.OLLAMA_MODEL || 'ollama') :
          null;

        llmStatus = { available: true, provider: providerForStatus, model: modelForStatus };
      } else {
        // Capture availability info for debugging
        const anyAvailable = Array.isArray(statuses) && statuses.some(s => s.available);
        llmStatus = { available: anyAvailable, provider: null, model: null };
      }
    } catch (e) {
      llmStatus = { available: false, provider: null, model: null };
    }
    
    const autostartYaml = [
      '# @type: evolution_autostart',
      '# @description: Autostart + diagnostics (printed before evolution begins)',
      'autostart:',
      `  ts_cli: true`,
      `  cwd: "${process.cwd()}"`,
      `  output: "${outputDir}"`,
      `  port: ${port}`,
      `  keep_running: ${keepRunning}`,
      `  interactive_menu: ${!noMenu && !keepRunning && process.stdin.isTTY}`,
      `  startup_timeout_ms: ${startupTimeoutMs}`,
      `  verbose: ${extraVerbose}`,
      `  log_file: "${logFile || 'none'}"`,
      `  llm_timeout_ms: ${llmTimeoutMs}`,
      '  llm:',
      `    provider_env: "${process.env.LLM_PROVIDER || 'auto'}"`,
      `    openrouter_model_env: "${process.env.OPENROUTER_MODEL || 'unset'}"`,
      `    openrouter_key_set: ${!!process.env.OPENROUTER_API_KEY}`,
      `    resolved_provider: "${llmStatus.provider || 'none'}"`,
      `    resolved_model: "${llmStatus.model || 'none'}"`
    ].join('\n');
    cliRenderer.codeblock('yaml', autostartYaml);
    if (llmDebugLines.length) {
      cliRenderer.codeblock('markdown', ['# LLM availability (debug)', ...llmDebugLines].join('\n'));
    }
    
    const setupYaml = [
      '# @type: evolution_setup',
      '# @description: Initial configuration for evolution pipeline',
      'setup:',
      `  prompt: "${prompt ? prompt.substring(0, 60) : contractPath}"`,
      `  output: "${outputDir}"`,
      `  port: ${port}`,
      '  llm:',
      `    available: ${llmStatus.available}`,
      `    provider: "${llmStatus.provider || 'none'}"`,
      `    model: "${llmStatus.model || 'none'}"`
    ].join('\n');
    cliRenderer.codeblock('yaml', setupYaml);
    console.log('');

    let progressTimer = null;
    progressTimer = setTimeout(() => {
      try {
        cliRenderer.codeblock('markdown', [
          '# evolve: startup timeout',
          '',
          'No further progress logs were printed quickly. This usually means one of:',
          '- waiting on a first LLM request (network/API key/model)',
          '- waiting on dependency install or project scaffolding',
          '- interactive menu waiting for input (use --no-menu)',
          '',
          '## quick checks',
          `- LLM_PROVIDER=${process.env.LLM_PROVIDER || 'auto'}`,
          `- OPENROUTER_API_KEY set: ${!!process.env.OPENROUTER_API_KEY}`,
          `- OPENROUTER_MODEL=${process.env.OPENROUTER_MODEL || 'unset'}`,
          `- outputDir=${outputDir}`,
          '',
          'Tip: rerun with `-v` and/or set `RECLAPP_EVOLVE_STARTUP_TIMEOUT_MS=10000`'
        ].join('\n'));
      } catch (e) {}
    }, startupTimeoutMs);

    // Start evolution lifecycle (iterative mode by default)
    if (prompt) {
      console.log(`üí¨ Starting iterative evolution from prompt: "${prompt}"\n`);
      await evolutionManager.evolveIteratively(prompt, 5);
      try {
        const st = evolutionManager.getStatus();
        if (st && typeof st.port === 'number') {
          port = st.port;
        }
      } catch (e) {}
    } else if (contractPath) {
      const fullPath = path.resolve(contractPath);
      if (fullPath.endsWith('.rcl.md')) {
        const result = parseMarkdownFile(fullPath);
        if (result.success && result.ir.aiPlan) {
          console.log(`üìÑ Found embedded AI Plan in: ${contractPath}`);
          await evolutionManager.start(result.ir.aiPlan);
        } else if (result.success) {
          const contract = irToContract(result.ir);
          console.log(`üìÑ Starting evolution from contract: ${contractPath}`);
          await evolutionManager.start(contract);
        } else {
          console.error(`‚ùå Failed to parse Markdown contract: ${result.errors[0]?.message}`);
          process.exit(1);
        }
      } else {
        const contract = require(path.resolve(contractPath)).default || require(path.resolve(contractPath));
        await evolutionManager.start(contract);
      }
      try {
        const st = evolutionManager.getStatus();
        if (st && typeof st.port === 'number') {
          port = st.port;
        }
      } catch (e) {}
    }

    if (progressTimer) {
      clearTimeout(progressTimer);
      progressTimer = null;
    }

    if (keepRunning) {
      console.log('\nüì° Evolution mode active. Monitoring for issues...');
      console.log('   Press Ctrl+C to stop\n');

      // Handle graceful shutdown
      process.on('SIGINT', async () => {
        console.log('\n\nüõë Shutting down evolution manager...');
        await evolutionManager.shutdown();
        process.exit(0);
      });

      // Keep process alive
      await new Promise(() => {}); // Never resolves
    } else {
      if (noMenu) {
        await evolutionManager.shutdown();
        cleanupLogging();
        return;
      }

      // Interactive mode - ask user what to do next
      console.log('\n‚úÖ Evolution complete\n');

      cliRenderer.heading(2, 'Actions');
      cliRenderer.codeblock('yaml', [
        'commands:',
        '  k: "keep running - monitor for issues"',
        '  r: "restart - regenerate service"',
        '  f: "fix - create ticket for LLM"',
        '  s: "support - create interactive ticket (type freely)"',
        '  c: "contract - show contract/contract.ai.json"',
        '  e: "state - show state/evolution-state.json"',
        '  l: "logs - view service logs"',
        '  S: "tasks - show task queue"',
        '  t: "test - run API health check"',
        `  o: "open - browser http://localhost:${port}"`,
        '  q: "quit - stop and exit"'
      ].join('\n'));

      console.log('> Tip: Use `--keep-running` (`-k`) to skip this menu\n');

      // Enable raw mode for single keypress detection
      if (!keepRunning && process.stdin.isTTY) {
        process.stdin.setRawMode(true);
        process.stdin.resume();

        let menuInputActive = false;

        function disableMenuInput() {
          if (!menuInputActive) return;
          process.stdin.removeListener('data', handleKeypress);
          menuInputActive = false;
        }

        function enableMenuInput() {
          if (menuInputActive) return;
          process.stdin.on('data', handleKeypress);
          menuInputActive = true;
        }

        async function handleKeypress(chunk) {
          const key = chunk.toString();
          // Ctrl+C
          if (key === '\u0003') {
            console.log('\nüõë Shutting down...');
            await evolutionManager.shutdown();
            process.exit(0);
          }

          const trimmed = key.trim();

          // Uppercase shortcuts (Shift+key)
          if (trimmed === 'S') {
            evolutionManager.printTasks();
            process.stdout.write('> Press key: ');
            return;
          }

          const k = trimmed.toLowerCase();

          switch (k) {
            case 'k':
              console.log('\nüì° Switching to keep-running mode...');
              console.log('   Monitoring service for issues. Press Ctrl+C to stop.\n');
              // Don't shutdown, keep monitoring
              return;

            case 'c':
              cliRenderer.heading(2, 'Contract');
              try {
                const contractPath = path.join(outputDir, 'contract', 'contract.ai.json');
                if (!fs.existsSync(contractPath)) {
                  cliRenderer.codeblock('log', `‚ö†Ô∏è Contract not found: ${contractPath}`);
                } else {
                  const json = JSON.parse(fs.readFileSync(contractPath, 'utf8'));
                  cliRenderer.codeblock('json', JSON.stringify(json, null, 2));
                }
              } catch (e) {
                cliRenderer.codeblock('log', `‚ö†Ô∏è Failed to load contract: ${e.message || e}`);
              }
              process.stdout.write('> Press key: ');
              return;

            case 'e':
              cliRenderer.heading(2, 'Evolution State');
              try {
                const statePath = path.join(outputDir, 'state', 'evolution-state.json');
                if (!fs.existsSync(statePath)) {
                  cliRenderer.codeblock('log', `‚ö†Ô∏è State not found: ${statePath}`);
                } else {
                  const json = JSON.parse(fs.readFileSync(statePath, 'utf8'));
                  cliRenderer.codeblock('json', JSON.stringify(json, null, 2));
                }
              } catch (e) {
                cliRenderer.codeblock('log', `‚ö†Ô∏è Failed to load state: ${e.message || e}`);
              }
              process.stdout.write('> Press key: ');
              return;

            case 'r':
              console.log('\nüîÑ Restarting evolution...');
              await evolutionManager.shutdown();
              await evolutionManager.startFromPrompt(prompt);
              console.log('\n‚úÖ Restart complete');
              disableMenuInput();
              process.stdin.setRawMode(false);
              await cmdEvolution(args, options); // Recursive call
              return;

            case 'f':
              // Switch to line mode for ticket input (disable menu shortcuts)
              disableMenuInput();
              process.stdin.setRawMode(false);
              cliRenderer.codeblock('markdown', [
                '## üé´ Create Fix Ticket for LLM',
                'Describe the issue you want the LLM to fix.',
                '',
                'Examples:',
                '- "Add pagination to the /api/v1/tasks endpoint"',
                '- "Fix the 500 error when creating a task without title"',
                '- "Add validation for email field in User entity"'
              ].join('\n'));
              
              const ticketRl = readline.createInterface({ 
                input: process.stdin, 
                output: process.stdout,
                terminal: true
              });
              ticketRl.on('SIGINT', () => {
                cliRenderer.codeblock('log', '‚ö†Ô∏è Ticket input canceled. Returning to menu.');
                ticketRl.close();
                process.stdin.setRawMode(true);
                enableMenuInput();
                process.stdout.write('> Press key: ');
              });
              
              ticketRl.question('üé´ Issue description: ', async (issueDescription) => {
                ticketRl.close();
                
                if (!issueDescription.trim()) {
                  cliRenderer.codeblock('log', '‚ö†Ô∏è No issue description provided. Returning to menu.');
                  process.stdin.setRawMode(true);
                  enableMenuInput();
                  process.stdout.write('> Press key: ');
                  return;
                }
                
                cliRenderer.codeblock('log', [
                  'üìù Creating ticket...',
                  `Issue: "${issueDescription}"`
                ].join('\n'));

                // Save ticket to file
                const ticketDir = path.join(outputDir, 'tickets');
                if (!fs.existsSync(ticketDir)) {
                  fs.mkdirSync(ticketDir, { recursive: true });
                }
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const ticketPath = path.join(ticketDir, `ticket_${timestamp}.md`);

                const recentLogs = (() => {
                  try {
                    const logsDir = path.join(outputDir, 'logs');
                    const logFiles = fs.readdirSync(logsDir).filter(f => f.endsWith('.rcl.md'));
                    if (logFiles.length > 0) {
                      const latestLog = path.join(logsDir, logFiles[logFiles.length - 1]);
                      return fs.readFileSync(latestLog, 'utf8').substring(0, 4000);
                    }
                  } catch (e) {}
                  return 'No logs available';
                })();

                const recentLogsBlock = fencedBlockString(recentLogs, 'markdown');
                
                const ticketContent = `# Fix Ticket

## Issue
${issueDescription}

## Context
- **Created**: ${new Date().toISOString()}
- **Service Port**: ${port}
- **Output Dir**: ${outputDir}
- **Original Prompt**: ${prompt}

## Status
- [ ] Pending LLM analysis
- [ ] Code changes generated
- [ ] Tests passing
- [ ] Deployed

## LLM Instructions
Please analyze this issue and generate the necessary code changes to fix it.
Consider:
1. What files need to be modified?
2. What is the root cause?
3. How can we add tests to prevent regression?

## Recent Logs
${recentLogsBlock}
`;
                
                fs.writeFileSync(ticketPath, ticketContent);
                cliRenderer.codeblock('log', `‚úÖ Ticket saved: ${ticketPath}`);
                
                // Try to fix with LLM if available
                cliRenderer.codeblock('log', 'ü§ñ Attempting to fix with LLM...');
                
                try {
                  const contractAI = require('../src/core/contract-ai');
                  const ollamaAvailable = await contractAI.checkOllamaAvailable();
                  
                  if (ollamaAvailable) {
                    cliRenderer.codeblock('log', 'Analyzing issue and generating fix...');
                    
                    // Trigger evolution with the issue as context
                    await evolutionManager.evolveWithFeedback(issueDescription);
                    
                    cliRenderer.codeblock('log', [
                      '‚úÖ LLM fix applied!',
                      'Restarting service to apply changes...'
                    ].join('\n'));
                    
                    // Update ticket status
                    const updatedTicket = ticketContent
                      .replace('- [ ] Pending LLM analysis', '- [x] Pending LLM analysis')
                      .replace('- [ ] Code changes generated', '- [x] Code changes generated');
                    fs.writeFileSync(ticketPath, updatedTicket);
                    
                  } else {
                    cliRenderer.codeblock('log', [
                      '‚ö†Ô∏è Ollama not available. Ticket saved for manual review.',
                      'üí° Start Ollama: ollama serve && ollama pull llama3'
                    ].join('\n'));
                  }
                } catch (e) {
                  cliRenderer.codeblock('log', [
                    `‚ö†Ô∏è Auto-fix failed: ${e.message}`,
                    'Ticket saved for manual review.'
                  ].join('\n'));
                }
                
                cliRenderer.codeblock('markdown', [
                  '## üìã Ticket',
                  `Path: \`${ticketPath}\``,
                  '',
                  'You can manually edit the ticket and re-run evolution.'
                ].join('\n'));
                
                // Return to raw mode for menu
                process.stdin.setRawMode(true);
                enableMenuInput();
                process.stdout.write('> Press key: ');
              });
              return;

            case 's':
              // Switch to line mode for ticket input (disable menu shortcuts)
              disableMenuInput();
              process.stdin.setRawMode(false);
              cliRenderer.codeblock('markdown', [
                '## üé´ Create Ticket',
                'Type freely ‚Äî shortcuts are disabled while you write.',
                '',
                'Press Enter to submit, Ctrl+C to cancel.'
              ].join('\n'));

              const supportRl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
                terminal: true
              });
              supportRl.on('SIGINT', () => {
                cliRenderer.codeblock('log', '‚ö†Ô∏è Ticket input canceled. Returning to menu.');
                supportRl.close();
                process.stdin.setRawMode(true);
                enableMenuInput();
                process.stdout.write('> Press key: ');
              });

              supportRl.question('üé´ Ticket: ', async (issueDescription) => {
                supportRl.close();

                if (!issueDescription.trim()) {
                  cliRenderer.codeblock('log', '‚ö†Ô∏è Empty ticket. Returning to menu.');
                  process.stdin.setRawMode(true);
                  enableMenuInput();
                  process.stdout.write('> Press key: ');
                  return;
                }

                // Reuse the same behavior as fix ticket: save + attempt evolveWithFeedback
                cliRenderer.codeblock('log', [
                  'üìù Creating ticket...',
                  `Issue: "${issueDescription}"`
                ].join('\n'));

                const ticketDir = path.join(outputDir, 'tickets');
                if (!fs.existsSync(ticketDir)) {
                  fs.mkdirSync(ticketDir, { recursive: true });
                }

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const ticketPath = path.join(ticketDir, `ticket_${timestamp}.md`);

                const recentLogs = (() => {
                  try {
                    const logsDir = path.join(outputDir, 'logs');
                    const logFiles = fs.readdirSync(logsDir).filter(f => f.endsWith('.rcl.md'));
                    if (logFiles.length > 0) {
                      const latestLog = path.join(logsDir, logFiles[logFiles.length - 1]);
                      return fs.readFileSync(latestLog, 'utf8').substring(0, 4000);
                    }
                  } catch (e) {}
                  return 'No logs available';
                })();

                const recentLogsBlock = fencedBlockString(recentLogs, 'markdown');

                const ticketContent = `# Ticket

## Issue
${issueDescription}

## Context
- **Created**: ${new Date().toISOString()}
- **Service Port**: ${port}
- **Output Dir**: ${outputDir}
- **Original Prompt**: ${prompt}

## Status
- [ ] Pending LLM analysis
- [ ] Code changes generated
- [ ] Tests passing
- [ ] Deployed

## LLM Instructions
Please analyze this issue and generate the necessary code changes to fix it.

## Recent Logs
${recentLogsBlock}
`;

                fs.writeFileSync(ticketPath, ticketContent);
                cliRenderer.codeblock('log', `‚úÖ Ticket saved: ${ticketPath}`);

                cliRenderer.codeblock('log', 'ü§ñ Attempting to fix with LLM...');
                try {
                  const contractAI = require('../src/core/contract-ai');
                  const ollamaAvailable = await contractAI.checkOllamaAvailable();

                  if (ollamaAvailable) {
                    cliRenderer.codeblock('log', 'Analyzing issue and generating fix...');
                    await evolutionManager.evolveWithFeedback(issueDescription);

                    cliRenderer.codeblock('log', '‚úÖ LLM fix applied!');

                    const updatedTicket = ticketContent
                      .replace('- [ ] Pending LLM analysis', '- [x] Pending LLM analysis')
                      .replace('- [ ] Code changes generated', '- [x] Code changes generated');
                    fs.writeFileSync(ticketPath, updatedTicket);
                  } else {
                    cliRenderer.codeblock('log', '‚ö†Ô∏è Ollama not available. Ticket saved for manual review.');
                  }
                } catch (e) {
                  cliRenderer.codeblock('log', [
                    `‚ö†Ô∏è Auto-fix failed: ${e.message}`,
                    'Ticket saved for manual review.'
                  ].join('\n'));
                }

                cliRenderer.codeblock('markdown', [
                  '## üìã Ticket',
                  `Path: \`${ticketPath}\``
                ].join('\n'));

                process.stdin.setRawMode(true);
                enableMenuInput();
                process.stdout.write('> Press key: ');
              });
              return;

            case 'l':
              cliRenderer.heading(2, 'Logs');
              try {
                const logsDir = path.join(outputDir, 'logs');
                const logFiles = fs.readdirSync(logsDir).filter(f => f.endsWith('.rcl.md'));
                if (logFiles.length > 0) {
                  const latestLog = path.join(logsDir, logFiles[logFiles.length - 1]);
                  const content = fs.readFileSync(latestLog, 'utf8');
                  const tailLines = 80;
                  const lines = content.split('\n');
                  const tail = lines.slice(-tailLines).join('\n');
                  cliRenderer.codeblock('yaml', `# @type: log_view\nlog:\n  file: "${latestLog}"\n  tail_lines: ${tailLines}`);
                  console.log('');
                  renderMarkdownWithFences(cliRenderer, tail);
                  console.log(`\n> Full log: \`${latestLog}\``);
                }
              } catch (e) {
                console.log('> No logs available yet.');
              }
              process.stdout.write('> Press key: ');
              return;

            case 't':
              cliRenderer.heading(2, 'Health Check');
              try {
                const url = `http://localhost:${port}/health`;
                const res = await fetch(url);
                const text = await res.text();
                let jsonOut = text.trim();
                try {
                  jsonOut = JSON.stringify(JSON.parse(text), null, 2);
                } catch (e) {}
                cliRenderer.codeblock('json', jsonOut);
                console.log('');
                cliRenderer.codeblock('yaml', `# @type: health_result\nresult: ${res.ok ? 'passed' : 'failed'}\nstatus: ${res.status}`);
              } catch (e) {
                const msg = (e && e.message) ? e.message : String(e);
                cliRenderer.codeblock('yaml', `# @type: health_result\nresult: failed\nerror: "${msg.replace(/\"/g, '\\\"').substring(0, 180)}"`);
              }
              process.stdout.write('> Press key: ');
              return;

            case 'o':
              let openUrl = `http://localhost:${port}/`;
              try {
                const res = await fetch(openUrl);
                if (!res.ok) {
                  openUrl = `http://localhost:${port}/health`;
                }
              } catch (e) {
                openUrl = `http://localhost:${port}/health`;
              }

              console.log(`\nüåê Opening ${openUrl} in browser...`);
              try {
                const { exec } = require('child_process');
                exec(`xdg-open ${openUrl} 2>/dev/null || open ${openUrl} 2>/dev/null`);
              } catch (e) {}
              process.stdout.write('> Press key: ');
              return;

            case 'q':
              console.log('\nüõë Shutting down service...');
              await evolutionManager.shutdown();
              console.log('üëã Goodbye!\n');
              process.exit(0);

            default:
              // Ignore other keys, show hint
              process.stdout.write('\r> Press key: ');
          }
        }

        enableMenuInput();

        // Keep process alive for interactive mode
        await new Promise(() => {});
      } else {
        // Non-TTY mode (piped input) - just shutdown
        console.log('üí° Tip: Run with --keep-running (-k) to keep the service alive');
        console.log('   Service exited (non-interactive mode)\n');
        await evolutionManager.shutdown();
      }
    }

  } catch (error) {
    console.error(`\n‚ùå Error: ${error.message}\n`);
    console.error('## Troubleshooting\n');
    console.error('```yaml');
    console.error('error:');
    console.error(`  message: "${error.message.substring(0, 80)}"`);
    
    // Context-specific error hints
    if (error.message.includes('EADDRINUSE') || error.message.includes('port')) {
      console.error('  type: "port_in_use"');
      console.error('  fix:');
      console.error('    - "--port 3001  # use different port"');
      console.error('    - "pkill -f node.*server  # kill existing"');
    } else if (error.message.includes('npm') || error.message.includes('install')) {
      console.error('  type: "npm_install_failed"');
      console.error('  fix:');
      console.error('    - "cd <output>/api && npm install"');
      console.error('    - "node --version  # requires 18+"');
    } else if (error.message.includes('ENOENT') || error.message.includes('not found')) {
      console.error('  type: "file_not_found"');
      console.error('  fix:');
      console.error('    - "check output directory exists"');
      console.error('    - "verify contract file path"');
    } else if (error.message.includes('Ollama') || error.message.includes('LLM')) {
      console.error('  type: "llm_connection_failed"');
      console.error('  fix:');
      console.error('    - "ollama serve  # start server"');
      console.error('    - "ollama pull mistral:7b-instruct"');
    } else {
      console.error('  type: "unknown"');
      console.error('  fix:');
      console.error('    - "--verbose  # more details"');
      console.error('    - "cat <output>/logs/*.rcl.md"');
    }
    console.error('```\n');
    console.error('> Docs: `./docs/30-evolution-system.md`');
    console.error('> Issues: https://github.com/wronai/contract/issues\n');
    
    if (options.verbose) console.error(error.stack);
    process.exit(1);
  }
}

// ============================================================================
// TASKS COMMAND
// ============================================================================

async function cmdTasks(args, options) {
  let taskFile = null;
  let watch = false;
  let workers = 3;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--watch' || args[i] === '-w') {
      watch = true;
    } else if (args[i] === '--workers' && args[i + 1]) {
      workers = parseInt(args[i + 1]); i++;
    } else if (!args[i].startsWith('-')) {
      taskFile = args[i];
    }
  }

  if (!taskFile) {
    console.error('‚ùå Usage: reclapp tasks <file.tasks> [--watch] [--workers N]');
    console.error('');
    console.error('## Task File Format\n');
    console.error('```bash');
    console.error('# Comments start with #');
    console.error('echo "Hello World"');
    console.error('npm install');
    console.error('npm run build  # timeout: 120');
    console.error('```\n');
    process.exit(1);
  }

  console.log('\n## Task Executor v1.0\n');
  console.log('```yaml');
  console.log('config:');
  console.log(`  file: "${taskFile}"`);
  console.log(`  workers: ${workers}`);
  console.log(`  watch: ${watch}`);
  console.log('```\n');

  try {
    const contractAI = require('../src/core/contract-ai');
    const executor = contractAI.createTaskExecutor({
      maxWorkers: workers,
      verbose: true
    });

    if (watch) {
      executor.startWatching(taskFile);
      console.log('> Watching for changes. Press Ctrl+C to stop.\n');
      
      process.on('SIGINT', () => {
        console.log('\nüõë Stopping task executor...');
        executor.stopWatching();
        executor.printMarkdown();
        process.exit(0);
      });

      await new Promise(() => {});
    } else {
      executor.addTasksFromFile(taskFile);
      await executor.waitForAll();
      
      console.log('\n## Final Status\n');
      executor.printMarkdown();
    }
  } catch (error) {
    console.error(`\n‚ùå Error: ${error.message}\n`);
    if (options.verbose) console.error(error.stack);
    process.exit(1);
  }
}

// ============================================================================
// SETUP COMMAND
// ============================================================================

async function cmdSetup(args, options) {
  // Python/Pydantic implementation - faster startup, better validation
  // Original TypeScript version archived at: archive/typescript-setup/cmdSetup.js
  const { spawn } = require('child_process');
  const setupScript = path.join(__dirname, '..', 'tools', 'reclapp-setup', 'setup.py');
  const venvPython = path.join(__dirname, '..', 'tools', 'reclapp-setup', 'venv', 'bin', 'python');
  
  // Build Python args from CLI args
  const pyArgs = [setupScript];
  
  for (let i = 0; i < args.length; i++) {
    if ((args[i] === '--output' || args[i] === '-o') && args[i + 1]) {
      pyArgs.push('-o', args[i + 1]);
      i++;
    } else if (args[i] === '--install' || args[i] === '-i') {
      pyArgs.push('--install');
    } else if (args[i] === '--dry-run') {
      pyArgs.push('--dry-run');
    } else if (args[i] === '-y' || args[i] === '--yes') {
      pyArgs.push('-y');
    } else if (args[i] === '--skip-optional') {
      pyArgs.push('--skip-optional');
    }
  }
  
  // Check if venv exists, if not use system python
  const fs = require('fs');
  const pythonPath = fs.existsSync(venvPython) ? venvPython : 'python3';
  
  return new Promise((resolve, reject) => {
    const proc = spawn(pythonPath, pyArgs, {
      stdio: 'inherit',
      cwd: process.cwd()
    });
    
    proc.on('close', (code) => {
      if (code !== 0) {
        process.exit(code);
      }
      resolve();
    });
    
    proc.on('error', (err) => {
      console.error('‚ùå Failed to run Python setup:', err.message);
      console.error('   Ensure Python 3 and dependencies are installed:');
      console.error('   cd tools/reclapp-setup && python3 -m venv venv && ./venv/bin/pip install -r requirements.txt');
      process.exit(1);
    });
  });
}

// ============================================================================
// MAIN
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(HELP);
    process.exit(0);
  }

  const command = args[0];
  const options = { 
    output: null, 
    verbose: args.includes('--verbose') || args.includes('-v'), 
    inPlace: args.includes('--in-place'),
    docker: args.includes('--docker') || args.includes('-d')
  };

  for (let i = 0; i < args.length; i++) {
    if ((args[i] === '--output' || args[i] === '-o') && args[i + 1]) {
      options.output = args[i + 1]; i++;
    }
  }

  const contractPath = args[1];

  switch (command) {
    case 'generate': case 'gen': case 'g':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdGenerate(contractPath, options); break;

    case 'dev': case 'd':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdDev(contractPath, options); break;

    case 'run': case 'r':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdRun(contractPath, options); break;

    case 'test': case 't':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdTest(contractPath, options); break;

    case 'deploy':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdDeploy(contractPath, options); break;

    case 'parse': case 'p':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdParse(contractPath); break;

    case 'validate': case 'v':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdValidate(contractPath); break;

    case 'list': case 'ls': case 'l':
      await cmdList(); break;

    case 'stop':
      await cmdStop(); break;

    case 'studio':
      await cmdStudio(); break;

    case 'chat': case 'ai':
      await cmdChat(); break;

    case 'convert': case 'conv':
      if (!contractPath) { console.error('‚ùå Missing input path'); process.exit(1); }
      // Parse --format option
      for (let i = 0; i < args.length; i++) {
        if (args[i] === '--format' && args[i + 1]) {
          options.format = args[i + 1]; i++;
        }
      }
      await cmdConvert(contractPath, options); break;

    case 'normalize': case 'norm':
      if (!contractPath) { console.error('‚ùå Missing input path'); process.exit(1); }
      await cmdNormalize(contractPath, options); break;

    case 'generate-ai': case 'gen-ai': case 'ai-gen':
      await cmdGenerateAI(args.slice(1), options); break;

    case 'evolve': case 'evolution': case 'evo':
      await cmdEvolution(args.slice(1), options); break;

    case 'analyze': case 'analyse':
      await cmdAnalyze(args.slice(1), options); break;

    case 'reverse': case 'rev':
      await cmdReverse(args.slice(1), options); break;

    case 'refactor': case 'refac':
      await cmdRefactor(args.slice(1), options); break;

    case 'tasks': case 'task':
      await cmdTasks(args.slice(1), options); break;

    case 'setup': case 'init': case 'doctor':
      await cmdSetup(args.slice(1), options); break;

    default:
      if (command.endsWith('.reclapp.ts') || command.endsWith('.ts') || command.endsWith('.rcl') || command.endsWith('.rcl.md') || command.endsWith('.contract.md')) {
        await cmdGenerate(command, options);
      } else {
        console.error(`‚ùå Unknown command: ${command}`);
        console.log(HELP);
        process.exit(1);
      }
  }
}

main().catch(err => {
  console.error('‚ùå Error:', err.message);
  process.exit(1);
});
