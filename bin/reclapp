#!/usr/bin/env node
/**
 * Reclapp CLI - Generate applications from DSL contracts
 * 
 * Uses generator modules from generator/ folder
 */

const path = require('path');
const fs = require('fs');

// Register TypeScript support
try {
  require('ts-node').register({
    transpileOnly: true,
    compilerOptions: {
      module: 'commonjs',
      target: 'ES2022',
      esModuleInterop: true,
      skipLibCheck: true
    }
  });
} catch (e) {
  try { require('tsx/cjs'); } catch (e2) { }
}

// Import generator after ts-node registration
let SimpleGenerator, generateFromContract;
try {
  const gen = require('../generator/core/simple-generator');
  SimpleGenerator = gen.SimpleGenerator;
  generateFromContract = gen.generateFromContract;
} catch (e) {
  // Fallback: use inline generator if module not found
  SimpleGenerator = null;
}

// Import Mini-DSL parser
let parseMini, parseMiniFile, miniToIR, irToMini;
try {
  const mini = require('../dsl/parser/mini');
  parseMini = mini.parseMini;
  parseMiniFile = mini.parseMiniFile;
  miniToIR = mini.miniToIR;
  irToMini = mini.irToMini;
} catch (e) {
  parseMiniFile = null;
}

// Import shared normalization helpers (used to auto-fix common LLM mistakes)
let normalizeMiniRclSource;
try {
  ({ normalizeMiniRclSource } = require('../lib/chat-core'));
} catch (e) {
  normalizeMiniRclSource = null;
}

// Import Markdown parser (.rcl.md)
let parseMarkdownFile, irToContract, writeMarkdownContract, contractToIR;
try {
  const md = require('../dsl/parser/markdown');
  parseMarkdownFile = md.parseMarkdownFile;
  irToContract = md.irToContract;
  const writer = require('../dsl/writer/markdown');
  writeMarkdownContract = writer.writeMarkdownContract;
  contractToIR = writer.contractToIR;
} catch (e) {
  parseMarkdownFile = null;
}

const HELP = `
Reclapp CLI - Generate applications from DSL contracts

Usage:
  reclapp <contract.reclapp.ts|.rcl>         Generate application
  reclapp run <contract>                     Generate, install, and run
  reclapp test <contract>                    Generate, run, and test API
  reclapp dev <contract>                     Generate and start dev servers
  reclapp deploy <contract>                  Generate and deploy with Docker
  reclapp validate <contract>                Validate contract
  reclapp convert <input> -o <output>        Convert between formats
  reclapp list                               List available contracts
  reclapp studio                             Interactive examples browser
  reclapp chat                               Interactive LLM contract designer
  reclapp stop                               Stop all running containers

Commands:
  generate    Generate full application to target/ folder
  run         Generate, install dependencies, and start servers
  test        Generate, run servers, and execute API tests
  dev         Generate and start development servers (API + Frontend)
  deploy      Generate and deploy with Docker Compose
  validate    Validate contract without generating
  convert     Convert between .reclapp.ts, .rcl (Mini-DSL) formats
  list        List all available contract files (.reclapp.ts, .rcl)
  studio      Interactive examples browser with tests
  stop        Stop all running Docker containers

Supported Formats:
  .reclapp.ts    TypeScript contract (original format)
  .reclapp.rcl   Mini-DSL contract (~87% less code)
  .rcl.md        Markdown contract (human-readable, AI-friendly)

Options:
  --output, -o <dir>    Output directory (default: ./target)
  --port <port>         API port (default: 8080)
  --verbose, -v         Verbose output
  --help, -h            Show this help

Examples:
  reclapp examples/crm/contracts/main.reclapp.ts
  reclapp examples/crm/contracts/main.reclapp.rcl
  reclapp examples/crm/contracts/main.rcl.md
  reclapp convert contract.rcl --format md
  reclapp convert contract.rcl.md --format ts
  reclapp studio
`;

// ============================================================================
// CONTRACT LOADING
// ============================================================================

async function loadContract(contractPath) {
  const fullPath = path.resolve(contractPath);
  
  if (!fs.existsSync(fullPath)) {
    console.error(`‚ùå Contract file not found: ${fullPath}`);
    process.exit(1);
  }

  // Handle Markdown (.rcl.md or .md) files
  if (fullPath.endsWith('.rcl.md') || (fullPath.endsWith('.md') && fs.readFileSync(fullPath, 'utf-8').includes('# entity:'))) {
    if (!parseMarkdownFile) {
      console.error('‚ùå Markdown parser not available');
      process.exit(1);
    }
    const result = parseMarkdownFile(fullPath);
    if (!result.success) {
      console.error('‚ùå Parse error:', result.errors[0]?.message || 'Unknown error');
      if (result.errors[0]?.line) {
        console.error(`   Line ${result.errors[0].line}`);
      }
      process.exit(1);
    }
    return irToContract(result.ir);
  }

  // Handle Mini-DSL (.rcl) files
  if (fullPath.endsWith('.rcl')) {
    if (!parseMiniFile) {
      console.error('‚ùå Mini-DSL parser not available');
      process.exit(1);
    }
    let result = parseMiniFile(fullPath);
    if (!result.success && normalizeMiniRclSource && parseMini) {
      try {
        const originalSource = fs.readFileSync(fullPath, 'utf-8');
        const normalizedSource = normalizeMiniRclSource(originalSource);
        result = parseMini(normalizedSource);
      } catch (e) {
        // ignore and fall through to error reporting
      }
    }
    if (!result.success) {
      console.error('‚ùå Parse error:', result.errors[0]?.message || 'Unknown error');
      console.error(`   Line ${result.errors[0]?.line}, Column ${result.errors[0]?.column}`);
      if (normalizeMiniRclSource) {
        console.error('   Hint: This contract may contain LLM-style syntax like field: type, or trailing commas.');
        console.error('         Re-save the contract from Reclapp Studio or use a normalized format.');
      }
      process.exit(1);
    }
    const ir = miniToIR(result.ast);
    return {
      app: ir.app,
      entities: ir.entities,
      events: ir.events,
      pipelines: ir.pipelines,
      alerts: ir.alerts,
      dashboards: ir.dashboards,
      sources: ir.sources,
      workflows: ir.workflows,
      config: ir.config
    };
  }

  // Handle TypeScript (.ts) files
  delete require.cache[require.resolve(fullPath)];
  const module = require(fullPath);
  const contract = module.contract || module.default || module;

  if (!contract.app?.name) {
    console.error('‚ùå Invalid contract - missing app.name');
    process.exit(1);
  }

  return contract;
}

// ============================================================================
// COMMANDS
// ============================================================================

async function cmdGenerate(contractPath, options) {
  const contract = await loadContract(contractPath);
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  
  if (SimpleGenerator) {
    const generator = new SimpleGenerator(contract, outputDir);
    const files = generator.generate();
    const written = generator.writeFiles(options.verbose);
    console.log(`\n‚úÖ Generated ${written} files to ${outputDir}`);
  } else {
    // Fallback inline generator (simplified)
    console.log(`\nüöÄ Generating ${contract.app.name} v${contract.app.version}...`);
    console.log(`üìÅ Output: ${outputDir}\n`);
    const InlineGenerator = require('./inline-generator');
    const gen = new InlineGenerator(contract, outputDir);
    const files = gen.generate();
    const written = gen.writeFiles(options.verbose);
    console.log(`\n‚úÖ Generated ${written} files to ${outputDir}`);
  }

  console.log(`
üì¶ Next steps:
  cd ${path.relative(process.cwd(), outputDir)}/api && npm install && npm run dev
  cd ${path.relative(process.cwd(), outputDir)}/frontend && npm install && npm run dev
`);
}

async function cmdDev(contractPath, options) {
  const { spawn } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');
  const frontendDir = path.join(outputDir, 'frontend');

  console.log('\nüì¶ Installing dependencies...');
  
  await new Promise(resolve => {
    spawn('npm', ['install'], { cwd: apiDir, stdio: 'inherit', shell: true }).on('close', resolve);
  });

  await new Promise(resolve => {
    spawn('npm', ['install'], { cwd: frontendDir, stdio: 'inherit', shell: true }).on('close', resolve);
  });

  console.log('\nüöÄ Starting development servers...\n');

  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'inherit', shell: true });
  const frontendProc = spawn('npm', ['run', 'dev'], { cwd: frontendDir, stdio: 'inherit', shell: true });

  process.on('SIGINT', () => {
    apiProc.kill();
    frontendProc.kill();
    process.exit(0);
  });
}

async function cmdRun(contractPath, options) {
  const { spawn, execSync } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');

  console.log('\nüì¶ Installing API dependencies...');
  execSync('npm install', { cwd: apiDir, stdio: 'inherit' });

  console.log('\nüöÄ Starting API server...\n');
  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'inherit', shell: true });

  await new Promise(resolve => setTimeout(resolve, 3000));

  console.log('\n‚úÖ Server running at http://localhost:8080');
  console.log('   Press Ctrl+C to stop\n');

  process.on('SIGINT', () => {
    apiProc.kill();
    process.exit(0);
  });

  await new Promise(() => {});
}

async function cmdTest(contractPath, options) {
  const { spawn, execSync } = require('child_process');
  const http = require('http');
  
  const contract = await loadContract(contractPath);
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');

  console.log('\nüì¶ Installing API dependencies...');
  execSync('npm install', { cwd: apiDir, stdio: 'pipe' });

  console.log('üöÄ Starting API server for testing...');
  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'pipe', shell: true });

  await new Promise(resolve => setTimeout(resolve, 3000));

  console.log('\nüß™ Running API tests...\n');

  const entities = contract.entities || [];
  let passed = 0, failed = 0;

  const request = (method, reqPath, body = null) => {
    return new Promise((resolve, reject) => {
      const opts = { hostname: 'localhost', port: 8080, path: reqPath, method, headers: { 'Content-Type': 'application/json' } };
      const req = http.request(opts, res => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          try { resolve({ status: res.statusCode, data: JSON.parse(data) }); }
          catch { resolve({ status: res.statusCode, data }); }
        });
      });
      req.on('error', reject);
      if (body) req.write(JSON.stringify(body));
      req.end();
    });
  };

  const test = async (name, fn) => {
    try { await fn(); console.log(`  ‚úÖ ${name}`); passed++; }
    catch (err) { console.log(`  ‚ùå ${name}: ${err.message}`); failed++; }
  };

  const assert = (cond, msg) => { if (!cond) throw new Error(msg); };

  await test('GET /api/health returns 200', async () => {
    const res = await request('GET', '/api/health');
    assert(res.status === 200, `Expected 200, got ${res.status}`);
  });

  for (const entity of entities) {
    const kebab = entity.name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    const endpoint = `/api/${kebab}s`;

    await test(`GET ${endpoint} returns 200`, async () => {
      const res = await request('GET', endpoint);
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`POST ${endpoint} creates item`, async () => {
      const res = await request('POST', endpoint, { name: `Test ${entity.name}` });
      assert(res.status === 201, `Expected 201, got ${res.status}`);
    });

    await test(`GET ${endpoint}/1 returns item`, async () => {
      const res = await request('GET', `${endpoint}/1`);
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`PUT ${endpoint}/1 updates item`, async () => {
      const res = await request('PUT', `${endpoint}/1`, { name: 'Updated' });
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`DELETE ${endpoint}/1 removes item`, async () => {
      const res = await request('DELETE', `${endpoint}/1`);
      assert(res.status === 204, `Expected 204, got ${res.status}`);
    });
  }

  apiProc.kill();
  console.log(`\nüìä Results: ${passed} passed, ${failed} failed\n`);
  if (failed > 0) process.exit(1);
}

async function cmdDeploy(contractPath, options) {
  const { execSync } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  
  // Stop any existing containers first
  console.log('\nüõë Stopping existing containers...');
  try {
    execSync('docker compose down --remove-orphans 2>/dev/null || true', { cwd: outputDir, stdio: 'pipe' });
    // Also stop any containers using our ports
    execSync('docker ps -q --filter "publish=8080" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=3000" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=5432" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
  } catch (e) { /* ignore */ }
  
  console.log('üê≥ Building Docker containers...\n');
  
  try {
    execSync('docker compose build', { cwd: outputDir, stdio: 'inherit' });
    console.log('\nüöÄ Starting containers...\n');
    execSync('docker compose up -d', { cwd: outputDir, stdio: 'inherit' });
    
    console.log('\n‚úÖ Deployment complete!');
    console.log('   API:      http://localhost:8080');
    console.log('   Frontend: http://localhost:3000');
    console.log('   Database: localhost:5432');
    console.log('\n   View logs: docker compose logs -f');
    console.log('   Stop:      docker compose down\n');
  } catch (err) {
    console.error('‚ùå Docker deployment failed. Make sure Docker is running.');
    process.exit(1);
  }
}

async function cmdValidate(contractPath) {
  console.log(`\nüîç Validating ${contractPath}...`);
  const contract = await loadContract(contractPath);
  
  const errors = [], warnings = [];
  if (!contract.app) errors.push('Missing app section');
  if (!contract.app?.name) errors.push('Missing app.name');
  if (!contract.app?.version) errors.push('Missing app.version');
  if (!contract.entities?.length) warnings.push('No entities defined');

  for (const entity of (contract.entities || [])) {
    if (!entity.name) errors.push('Entity missing name');
    if (!entity.fields?.length) warnings.push(`Entity ${entity.name} has no fields`);
  }

  if (errors.length) {
    console.log('\n‚ùå Validation failed:');
    errors.forEach(e => console.log(`  - ${e}`));
    process.exit(1);
  }

  if (warnings.length) {
    console.log('\n‚ö†Ô∏è  Warnings:');
    warnings.forEach(w => console.log(`  - ${w}`));
  }

  console.log(`\n‚úÖ Contract is valid!`);
  console.log(`   App: ${contract.app.name} v${contract.app.version}`);
  console.log(`   Entities: ${contract.entities?.length || 0}`);
  console.log(`   Events: ${contract.events?.length || 0}`);
  console.log(`   Dashboards: ${contract.dashboards?.length || 0}`);
}

async function cmdConvert(inputPath, options = {}) {
  const fullInput = path.resolve(inputPath);
  if (!fs.existsSync(fullInput)) {
    console.error(`‚ùå Input file not found: ${fullInput}`);
    process.exit(1);
  }

  const targetFormat = options.format || 'md';
  console.log(`\nüîÑ Converting ${inputPath} to ${targetFormat}...`);

  // Load source contract
  let ir;
  
  if (fullInput.endsWith('.rcl.md') || fullInput.endsWith('.md')) {
    // From Markdown
    if (!parseMarkdownFile) {
      console.error('‚ùå Markdown parser not available');
      process.exit(1);
    }
    const result = parseMarkdownFile(fullInput);
    if (!result.success) {
      console.error('‚ùå Parse error:', result.errors[0]?.message);
      process.exit(1);
    }
    ir = result.ir;
  } else if (fullInput.endsWith('.rcl')) {
    // From Mini-DSL
    if (!parseMiniFile) {
      console.error('‚ùå Mini-DSL parser not available');
      process.exit(1);
    }
    const result = parseMiniFile(fullInput);
    if (!result.success) {
      console.error('‚ùå Parse error:', result.errors[0]?.message);
      process.exit(1);
    }
    ir = miniToIR(result.ast);
  } else if (fullInput.endsWith('.ts')) {
    // From TypeScript
    delete require.cache[require.resolve(fullInput)];
    const mod = require(fullInput);
    const contract = mod.contract || mod.default || mod;
    ir = {
      app: contract.app,
      entities: contract.entities || [],
      enums: contract.enums || [],
      events: contract.events || [],
      pipelines: contract.pipelines || [],
      alerts: contract.alerts || [],
      dashboards: contract.dashboards || [],
      sources: contract.sources || [],
      workflows: contract.workflows || [],
      config: contract.config || {},
      env: contract.env || []
    };
  } else {
    console.error('‚ùå Unknown input format. Use .rcl, .rcl.md, or .ts');
    process.exit(1);
  }

  // Convert to target format
  let output, outPath;

  switch (targetFormat) {
    case 'md':
    case 'markdown':
      if (!writeMarkdownContract) {
        console.error('‚ùå Markdown writer not available');
        process.exit(1);
      }
      output = writeMarkdownContract(ir, [], { includeConversation: false });
      outPath = options.output || inputPath.replace(/\.(reclapp\.ts|reclapp\.rcl|rcl|ts)$/, '.rcl.md');
      break;

    case 'ts':
    case 'typescript':
      output = generateTypeScriptContract(ir);
      outPath = options.output || inputPath.replace(/\.(rcl\.md|rcl|md)$/, '.reclapp.ts');
      break;

    case 'rcl':
    case 'mini':
      if (!irToMini) {
        console.error('‚ùå Mini-DSL writer not available');
        process.exit(1);
      }
      output = irToMini(ir);
      outPath = options.output || inputPath.replace(/\.(rcl\.md|reclapp\.ts|ts|md)$/, '.reclapp.rcl');
      break;

    default:
      console.error(`‚ùå Unknown target format: ${targetFormat}. Use md, ts, or rcl`);
      process.exit(1);
  }

  fs.writeFileSync(outPath, output);
  console.log(`‚úÖ Converted to ${outPath}`);
}

function generateTypeScriptContract(ir) {
  const lines = [
    '// Generated from Mini-DSL contract',
    `// App: ${ir.app?.name || 'Unknown'}`,
    '',
    'export const contract = {',
    `  app: ${JSON.stringify(ir.app, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  entities: ${JSON.stringify(ir.entities, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  events: ${JSON.stringify(ir.events, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  pipelines: ${JSON.stringify(ir.pipelines, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  alerts: ${JSON.stringify(ir.alerts, null, 4).replace(/\n/g, '\n  ')},`,
    '',
    `  dashboards: ${JSON.stringify(ir.dashboards, null, 4).replace(/\n/g, '\n  ')},`,
    '};',
    ''
  ];
  return lines.join('\n');
}

async function cmdList() {
  console.log('\nüìã Available contracts:\n');
  
  const findContracts = (dir, prefix = '') => {
    if (!fs.existsSync(dir)) return [];
    const results = [];
    for (const item of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules' && item !== 'target') {
        results.push(...findContracts(fullPath, path.join(prefix, item)));
      } else if (item.endsWith('.reclapp.ts') || item.endsWith('.reclapp.rcl') || item.endsWith('.rcl.md')) {
        results.push(path.join(prefix, item));
      }
    }
    return results;
  };

  const contracts = findContracts(process.cwd());
  if (contracts.length === 0) console.log('  No contracts found (.reclapp.ts, .reclapp.rcl, or .rcl.md)');
  else {
    const tsContracts = contracts.filter(c => c.endsWith('.ts'));
    const rclContracts = contracts.filter(c => c.endsWith('.rcl') && !c.endsWith('.rcl.md'));
    const mdContracts = contracts.filter(c => c.endsWith('.rcl.md'));
    if (tsContracts.length) {
      console.log('  TypeScript (.reclapp.ts):');
      tsContracts.forEach(c => console.log(`    ${c}`));
    }
    if (rclContracts.length) {
      console.log('  Mini-DSL (.reclapp.rcl):');
      rclContracts.forEach(c => console.log(`    ${c}`));
    }
    if (mdContracts.length) {
      console.log('  Markdown (.rcl.md):');
      mdContracts.forEach(c => console.log(`    ${c}`));
    }
  }
  console.log('');
}

async function cmdStop() {
  const { execSync } = require('child_process');
  
  console.log('\nüõë Stopping all Reclapp containers...\n');
  
  try {
    // Stop containers on common ports
    execSync('docker ps -q --filter "publish=8080" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=3000" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=5432" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    
    // Stop target containers by name
    execSync('docker ps -q --filter "name=target" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    
    console.log('‚úÖ All containers stopped.\n');
  } catch (e) {
    console.log('‚úÖ No running containers found.\n');
  }
}

async function cmdChat() {
  // Launch the interactive chat CLI
  const { spawn } = require('child_process');
  const chatPath = path.join(__dirname, 'reclapp-chat');
  
  if (!fs.existsSync(chatPath)) {
    console.error('‚ùå Chat module not found. Run from project root.');
    process.exit(1);
  }
  
  const child = spawn('node', [chatPath], {
    stdio: 'inherit',
    cwd: process.cwd()
  });
  
  child.on('close', (code) => process.exit(code));
}

async function cmdStudio() {
  const readline = require('readline');
  const { execSync } = require('child_process');
  
  const findContracts = (dir, prefix = '') => {
    if (!fs.existsSync(dir)) return [];
    const results = [];
    for (const item of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules' && item !== 'target') {
        results.push(...findContracts(fullPath, path.join(prefix, item)));
      } else if (item.endsWith('.reclapp.ts') || item.endsWith('.reclapp.rcl') || item.endsWith('.rcl.md')) {
        results.push({ path: path.join(prefix, item), full: fullPath });
      }
    }
    return results;
  };

  const contracts = findContracts(process.cwd());
  
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üöÄ RECLAPP STUDIO                         ‚ïë
‚ïë        Interactive Examples Browser (TS + RCL + MD)          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

  if (contracts.length === 0) {
    console.log('  No contracts found (.reclapp.ts, .reclapp.rcl, or .rcl.md)\n');
    return;
  }

  // Load contract info
  const examples = [];
  for (const c of contracts) {
    try {
      let contract;
      if (c.full.endsWith('.rcl.md')) {
        // Load Markdown file
        if (parseMarkdownFile) {
          const result = parseMarkdownFile(c.full);
          if (result.success) {
            contract = irToContract(result.ir);
          } else {
            throw new Error('Parse error');
          }
        } else {
          throw new Error('Markdown parser not available');
        }
      } else if (c.full.endsWith('.rcl')) {
        // Load RCL file
        if (parseMiniFile) {
          const result = parseMiniFile(c.full);
          if (result.success) {
            const ir = miniToIR(result.ast);
            contract = { app: ir.app, entities: ir.entities, events: ir.events };
          } else {
            throw new Error('Parse error');
          }
        } else {
          throw new Error('Parser not available');
        }
      } else {
        // Load TS file
        delete require.cache[require.resolve(c.full)];
        const mod = require(c.full);
        contract = mod.contract || mod.default || mod;
      }
      let ext = '.reclapp.ts';
      let format = 'ts';
      if (c.full.endsWith('.rcl.md')) { ext = '.rcl.md'; format = 'md'; }
      else if (c.full.endsWith('.rcl')) { ext = '.reclapp.rcl'; format = 'rcl'; }
      examples.push({
        path: c.path,
        full: c.full,
        name: contract.app?.name || path.basename(c.path, ext),
        version: contract.app?.version || '1.0.0',
        description: contract.app?.description || '',
        entities: contract.entities?.length || 0,
        events: contract.events?.length || 0,
        format
      });
    } catch (e) {
      examples.push({ path: c.path, full: c.full, name: path.basename(c.path), error: true });
    }
  }

  console.log('Available Examples:\n');
  examples.forEach((ex, i) => {
    if (ex.error) {
      console.log(`  ${i + 1}. ‚ùå ${ex.path} (invalid contract)`);
    } else {
      console.log(`  ${i + 1}. ${ex.name} v${ex.version}`);
      console.log(`     ${ex.description || 'No description'}`);
      console.log(`     üì¶ ${ex.entities} entities, ${ex.events} events`);
      console.log(`     üìÑ ${ex.path}\n`);
    }
  });

  console.log(`
Commands:
  [1-${examples.length}]  Select example
  g <n>    Generate example
  t <n>    Test example
  d <n>    Deploy example
  s        Stop all containers
  q        Quit
`);

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  
  const prompt = () => {
    rl.question('studio> ', async (answer) => {
      const parts = answer.trim().split(/\s+/);
      const cmd = parts[0];
      const num = parseInt(parts[1] || parts[0]) - 1;
      
      if (cmd === 'q' || cmd === 'quit' || cmd === 'exit') {
        console.log('\nüëã Goodbye!\n');
        rl.close();
        return;
      }
      
      if (cmd === 's' || cmd === 'stop') {
        await cmdStop();
        prompt();
        return;
      }
      
      if ((cmd === 'g' || cmd === 'generate') && num >= 0 && num < examples.length) {
        await cmdGenerate(examples[num].full, { verbose: true });
        prompt();
        return;
      }
      
      if ((cmd === 't' || cmd === 'test') && num >= 0 && num < examples.length) {
        await cmdTest(examples[num].full, {});
        prompt();
        return;
      }
      
      if ((cmd === 'd' || cmd === 'deploy') && num >= 0 && num < examples.length) {
        await cmdDeploy(examples[num].full, {});
        prompt();
        return;
      }
      
      // Direct number selection - show menu
      if (!isNaN(parseInt(cmd)) && parseInt(cmd) >= 1 && parseInt(cmd) <= examples.length) {
        const ex = examples[parseInt(cmd) - 1];
        console.log(`\n  Selected: ${ex.name}\n`);
        console.log(`  Actions:`);
        console.log(`    g ${cmd}  - Generate`);
        console.log(`    t ${cmd}  - Test`);
        console.log(`    d ${cmd}  - Deploy\n`);
      }
      
      prompt();
    });
  };
  
  prompt();
}

// ============================================================================
// MAIN
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(HELP);
    process.exit(0);
  }

  const command = args[0];
  const options = { output: null, verbose: args.includes('--verbose') || args.includes('-v') };

  for (let i = 0; i < args.length; i++) {
    if ((args[i] === '--output' || args[i] === '-o') && args[i + 1]) {
      options.output = args[i + 1]; i++;
    }
  }

  const contractPath = args[1];

  switch (command) {
    case 'generate': case 'gen': case 'g':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdGenerate(contractPath, options); break;

    case 'dev': case 'd':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdDev(contractPath, options); break;

    case 'run': case 'r':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdRun(contractPath, options); break;

    case 'test': case 't':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdTest(contractPath, options); break;

    case 'deploy':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdDeploy(contractPath, options); break;

    case 'validate': case 'v':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdValidate(contractPath); break;

    case 'list': case 'ls': case 'l':
      await cmdList(); break;

    case 'stop':
      await cmdStop(); break;

    case 'studio':
      await cmdStudio(); break;

    case 'chat': case 'ai':
      await cmdChat(); break;

    case 'convert': case 'conv':
      if (!contractPath) { console.error('‚ùå Missing input path'); process.exit(1); }
      // Parse --format option
      for (let i = 0; i < args.length; i++) {
        if (args[i] === '--format' && args[i + 1]) {
          options.format = args[i + 1]; i++;
        }
      }
      await cmdConvert(contractPath, options); break;

    default:
      if (command.endsWith('.reclapp.ts') || command.endsWith('.ts') || command.endsWith('.rcl') || command.endsWith('.rcl.md')) {
        await cmdGenerate(command, options);
      } else {
        console.error(`‚ùå Unknown command: ${command}`);
        console.log(HELP);
        process.exit(1);
      }
  }
}

main().catch(err => {
  console.error('‚ùå Error:', err.message);
  process.exit(1);
});
