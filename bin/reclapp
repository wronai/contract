#!/usr/bin/env node
/**
 * Reclapp CLI - Generate applications from DSL contracts
 * 
 * Uses generator modules from generator/ folder
 */

const path = require('path');
const fs = require('fs');

// Register TypeScript support
try {
  require('ts-node').register({
    transpileOnly: true,
    compilerOptions: {
      module: 'commonjs',
      target: 'ES2022',
      esModuleInterop: true,
      skipLibCheck: true
    }
  });
} catch (e) {
  try { require('tsx/cjs'); } catch (e2) { }
}

// Import generator after ts-node registration
let SimpleGenerator, generateFromContract;
try {
  const gen = require('../generator/core/simple-generator');
  SimpleGenerator = gen.SimpleGenerator;
  generateFromContract = gen.generateFromContract;
} catch (e) {
  // Fallback: use inline generator if module not found
  SimpleGenerator = null;
}

const HELP = `
Reclapp CLI - Generate applications from DSL contracts

Usage:
  reclapp <contract.reclapp.ts>              Generate application
  reclapp run <contract.reclapp.ts>          Generate, install, and run
  reclapp test <contract.reclapp.ts>         Generate, run, and test API
  reclapp dev <contract.reclapp.ts>          Generate and start dev servers
  reclapp deploy <contract.reclapp.ts>       Generate and deploy with Docker
  reclapp validate <contract.reclapp.ts>     Validate contract
  reclapp list                               List available contracts
  reclapp studio                             Interactive examples browser
  reclapp stop                               Stop all running containers

Commands:
  generate    Generate full application to target/ folder
  run         Generate, install dependencies, and start servers
  test        Generate, run servers, and execute API tests
  dev         Generate and start development servers (API + Frontend)
  deploy      Generate and deploy with Docker Compose
  validate    Validate contract without generating
  list        List all available contract files
  studio      Interactive examples browser with tests
  stop        Stop all running Docker containers

Options:
  --output, -o <dir>    Output directory (default: ./target)
  --port <port>         API port (default: 8080)
  --verbose, -v         Verbose output
  --help, -h            Show this help

Examples:
  reclapp examples/crm/contracts/main.reclapp.ts
  reclapp run examples/crm/contracts/main.reclapp.ts
  reclapp studio
  reclapp stop
`;

// ============================================================================
// CONTRACT LOADING
// ============================================================================

async function loadContract(contractPath) {
  const fullPath = path.resolve(contractPath);
  
  if (!fs.existsSync(fullPath)) {
    console.error(`‚ùå Contract file not found: ${fullPath}`);
    process.exit(1);
  }

  delete require.cache[require.resolve(fullPath)];
  const module = require(fullPath);
  const contract = module.contract || module.default || module;

  if (!contract.app?.name) {
    console.error('‚ùå Invalid contract - missing app.name');
    process.exit(1);
  }

  return contract;
}

// ============================================================================
// COMMANDS
// ============================================================================

async function cmdGenerate(contractPath, options) {
  const contract = await loadContract(contractPath);
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  
  if (SimpleGenerator) {
    const generator = new SimpleGenerator(contract, outputDir);
    const files = generator.generate();
    const written = generator.writeFiles(options.verbose);
    console.log(`\n‚úÖ Generated ${written} files to ${outputDir}`);
  } else {
    // Fallback inline generator (simplified)
    console.log(`\nüöÄ Generating ${contract.app.name} v${contract.app.version}...`);
    console.log(`üìÅ Output: ${outputDir}\n`);
    const InlineGenerator = require('./inline-generator');
    const gen = new InlineGenerator(contract, outputDir);
    const files = gen.generate();
    const written = gen.writeFiles(options.verbose);
    console.log(`\n‚úÖ Generated ${written} files to ${outputDir}`);
  }

  console.log(`
üì¶ Next steps:
  cd ${path.relative(process.cwd(), outputDir)}/api && npm install && npm run dev
  cd ${path.relative(process.cwd(), outputDir)}/frontend && npm install && npm run dev
`);
}

async function cmdDev(contractPath, options) {
  const { spawn } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');
  const frontendDir = path.join(outputDir, 'frontend');

  console.log('\nüì¶ Installing dependencies...');
  
  await new Promise(resolve => {
    spawn('npm', ['install'], { cwd: apiDir, stdio: 'inherit', shell: true }).on('close', resolve);
  });

  await new Promise(resolve => {
    spawn('npm', ['install'], { cwd: frontendDir, stdio: 'inherit', shell: true }).on('close', resolve);
  });

  console.log('\nüöÄ Starting development servers...\n');

  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'inherit', shell: true });
  const frontendProc = spawn('npm', ['run', 'dev'], { cwd: frontendDir, stdio: 'inherit', shell: true });

  process.on('SIGINT', () => {
    apiProc.kill();
    frontendProc.kill();
    process.exit(0);
  });
}

async function cmdRun(contractPath, options) {
  const { spawn, execSync } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');

  console.log('\nüì¶ Installing API dependencies...');
  execSync('npm install', { cwd: apiDir, stdio: 'inherit' });

  console.log('\nüöÄ Starting API server...\n');
  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'inherit', shell: true });

  await new Promise(resolve => setTimeout(resolve, 3000));

  console.log('\n‚úÖ Server running at http://localhost:8080');
  console.log('   Press Ctrl+C to stop\n');

  process.on('SIGINT', () => {
    apiProc.kill();
    process.exit(0);
  });

  await new Promise(() => {});
}

async function cmdTest(contractPath, options) {
  const { spawn, execSync } = require('child_process');
  const http = require('http');
  
  const contract = await loadContract(contractPath);
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  const apiDir = path.join(outputDir, 'api');

  console.log('\nüì¶ Installing API dependencies...');
  execSync('npm install', { cwd: apiDir, stdio: 'pipe' });

  console.log('üöÄ Starting API server for testing...');
  const apiProc = spawn('npm', ['run', 'dev'], { cwd: apiDir, stdio: 'pipe', shell: true });

  await new Promise(resolve => setTimeout(resolve, 3000));

  console.log('\nüß™ Running API tests...\n');

  const entities = contract.entities || [];
  let passed = 0, failed = 0;

  const request = (method, reqPath, body = null) => {
    return new Promise((resolve, reject) => {
      const opts = { hostname: 'localhost', port: 8080, path: reqPath, method, headers: { 'Content-Type': 'application/json' } };
      const req = http.request(opts, res => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          try { resolve({ status: res.statusCode, data: JSON.parse(data) }); }
          catch { resolve({ status: res.statusCode, data }); }
        });
      });
      req.on('error', reject);
      if (body) req.write(JSON.stringify(body));
      req.end();
    });
  };

  const test = async (name, fn) => {
    try { await fn(); console.log(`  ‚úÖ ${name}`); passed++; }
    catch (err) { console.log(`  ‚ùå ${name}: ${err.message}`); failed++; }
  };

  const assert = (cond, msg) => { if (!cond) throw new Error(msg); };

  await test('GET /api/health returns 200', async () => {
    const res = await request('GET', '/api/health');
    assert(res.status === 200, `Expected 200, got ${res.status}`);
  });

  for (const entity of entities) {
    const kebab = entity.name.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    const endpoint = `/api/${kebab}s`;

    await test(`GET ${endpoint} returns 200`, async () => {
      const res = await request('GET', endpoint);
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`POST ${endpoint} creates item`, async () => {
      const res = await request('POST', endpoint, { name: `Test ${entity.name}` });
      assert(res.status === 201, `Expected 201, got ${res.status}`);
    });

    await test(`GET ${endpoint}/1 returns item`, async () => {
      const res = await request('GET', `${endpoint}/1`);
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`PUT ${endpoint}/1 updates item`, async () => {
      const res = await request('PUT', `${endpoint}/1`, { name: 'Updated' });
      assert(res.status === 200, `Expected 200, got ${res.status}`);
    });

    await test(`DELETE ${endpoint}/1 removes item`, async () => {
      const res = await request('DELETE', `${endpoint}/1`);
      assert(res.status === 204, `Expected 204, got ${res.status}`);
    });
  }

  apiProc.kill();
  console.log(`\nüìä Results: ${passed} passed, ${failed} failed\n`);
  if (failed > 0) process.exit(1);
}

async function cmdDeploy(contractPath, options) {
  const { execSync } = require('child_process');
  
  await cmdGenerate(contractPath, { ...options, verbose: false });
  
  const outputDir = options.output || path.join(path.dirname(contractPath), '..', 'target');
  
  // Stop any existing containers first
  console.log('\nüõë Stopping existing containers...');
  try {
    execSync('docker compose down --remove-orphans 2>/dev/null || true', { cwd: outputDir, stdio: 'pipe' });
    // Also stop any containers using our ports
    execSync('docker ps -q --filter "publish=8080" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=3000" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=5432" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
  } catch (e) { /* ignore */ }
  
  console.log('üê≥ Building Docker containers...\n');
  
  try {
    execSync('docker compose build', { cwd: outputDir, stdio: 'inherit' });
    console.log('\nüöÄ Starting containers...\n');
    execSync('docker compose up -d', { cwd: outputDir, stdio: 'inherit' });
    
    console.log('\n‚úÖ Deployment complete!');
    console.log('   API:      http://localhost:8080');
    console.log('   Frontend: http://localhost:3000');
    console.log('   Database: localhost:5432');
    console.log('\n   View logs: docker compose logs -f');
    console.log('   Stop:      docker compose down\n');
  } catch (err) {
    console.error('‚ùå Docker deployment failed. Make sure Docker is running.');
    process.exit(1);
  }
}

async function cmdValidate(contractPath) {
  console.log(`\nüîç Validating ${contractPath}...`);
  const contract = await loadContract(contractPath);
  
  const errors = [], warnings = [];
  if (!contract.app) errors.push('Missing app section');
  if (!contract.app?.name) errors.push('Missing app.name');
  if (!contract.app?.version) errors.push('Missing app.version');
  if (!contract.entities?.length) warnings.push('No entities defined');

  for (const entity of (contract.entities || [])) {
    if (!entity.name) errors.push('Entity missing name');
    if (!entity.fields?.length) warnings.push(`Entity ${entity.name} has no fields`);
  }

  if (errors.length) {
    console.log('\n‚ùå Validation failed:');
    errors.forEach(e => console.log(`  - ${e}`));
    process.exit(1);
  }

  if (warnings.length) {
    console.log('\n‚ö†Ô∏è  Warnings:');
    warnings.forEach(w => console.log(`  - ${w}`));
  }

  console.log(`\n‚úÖ Contract is valid!`);
  console.log(`   App: ${contract.app.name} v${contract.app.version}`);
  console.log(`   Entities: ${contract.entities?.length || 0}`);
  console.log(`   Events: ${contract.events?.length || 0}`);
  console.log(`   Dashboards: ${contract.dashboards?.length || 0}`);
}

async function cmdList() {
  console.log('\nüìã Available contracts:\n');
  
  const findContracts = (dir, prefix = '') => {
    if (!fs.existsSync(dir)) return [];
    const results = [];
    for (const item of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules' && item !== 'target') {
        results.push(...findContracts(fullPath, path.join(prefix, item)));
      } else if (item.endsWith('.reclapp.ts')) {
        results.push(path.join(prefix, item));
      }
    }
    return results;
  };

  const contracts = findContracts(process.cwd());
  if (contracts.length === 0) console.log('  No .reclapp.ts contracts found.');
  else contracts.forEach(c => console.log(`  ${c}`));
  console.log('');
}

async function cmdStop() {
  const { execSync } = require('child_process');
  
  console.log('\nüõë Stopping all Reclapp containers...\n');
  
  try {
    // Stop containers on common ports
    execSync('docker ps -q --filter "publish=8080" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=3000" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    execSync('docker ps -q --filter "publish=5432" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    
    // Stop target containers by name
    execSync('docker ps -q --filter "name=target" | xargs -r docker stop 2>/dev/null || true', { stdio: 'pipe' });
    
    console.log('‚úÖ All containers stopped.\n');
  } catch (e) {
    console.log('‚úÖ No running containers found.\n');
  }
}

async function cmdStudio() {
  const readline = require('readline');
  const { execSync } = require('child_process');
  
  const findContracts = (dir, prefix = '') => {
    if (!fs.existsSync(dir)) return [];
    const results = [];
    for (const item of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);
      if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules' && item !== 'target') {
        results.push(...findContracts(fullPath, path.join(prefix, item)));
      } else if (item.endsWith('.reclapp.ts')) {
        results.push({ path: path.join(prefix, item), full: fullPath });
      }
    }
    return results;
  };

  const contracts = findContracts(process.cwd());
  
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üöÄ RECLAPP STUDIO                         ‚ïë
‚ïë              Interactive Examples Browser                     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`);

  if (contracts.length === 0) {
    console.log('  No .reclapp.ts contracts found.\n');
    return;
  }

  // Load contract info
  const examples = [];
  for (const c of contracts) {
    try {
      delete require.cache[require.resolve(c.full)];
      const mod = require(c.full);
      const contract = mod.contract || mod.default || mod;
      examples.push({
        path: c.path,
        full: c.full,
        name: contract.app?.name || path.basename(c.path, '.reclapp.ts'),
        version: contract.app?.version || '1.0.0',
        description: contract.app?.description || '',
        entities: contract.entities?.length || 0,
        events: contract.events?.length || 0
      });
    } catch (e) {
      examples.push({ path: c.path, full: c.full, name: path.basename(c.path), error: true });
    }
  }

  console.log('Available Examples:\n');
  examples.forEach((ex, i) => {
    if (ex.error) {
      console.log(`  ${i + 1}. ‚ùå ${ex.path} (invalid contract)`);
    } else {
      console.log(`  ${i + 1}. ${ex.name} v${ex.version}`);
      console.log(`     ${ex.description || 'No description'}`);
      console.log(`     üì¶ ${ex.entities} entities, ${ex.events} events`);
      console.log(`     üìÑ ${ex.path}\n`);
    }
  });

  console.log(`
Commands:
  [1-${examples.length}]  Select example
  g <n>    Generate example
  t <n>    Test example
  d <n>    Deploy example
  s        Stop all containers
  q        Quit
`);

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  
  const prompt = () => {
    rl.question('studio> ', async (answer) => {
      const parts = answer.trim().split(/\s+/);
      const cmd = parts[0];
      const num = parseInt(parts[1] || parts[0]) - 1;
      
      if (cmd === 'q' || cmd === 'quit' || cmd === 'exit') {
        console.log('\nüëã Goodbye!\n');
        rl.close();
        return;
      }
      
      if (cmd === 's' || cmd === 'stop') {
        await cmdStop();
        prompt();
        return;
      }
      
      if ((cmd === 'g' || cmd === 'generate') && num >= 0 && num < examples.length) {
        await cmdGenerate(examples[num].full, { verbose: true });
        prompt();
        return;
      }
      
      if ((cmd === 't' || cmd === 'test') && num >= 0 && num < examples.length) {
        await cmdTest(examples[num].full, {});
        prompt();
        return;
      }
      
      if ((cmd === 'd' || cmd === 'deploy') && num >= 0 && num < examples.length) {
        await cmdDeploy(examples[num].full, {});
        prompt();
        return;
      }
      
      // Direct number selection - show menu
      if (!isNaN(parseInt(cmd)) && parseInt(cmd) >= 1 && parseInt(cmd) <= examples.length) {
        const ex = examples[parseInt(cmd) - 1];
        console.log(`\n  Selected: ${ex.name}\n`);
        console.log(`  Actions:`);
        console.log(`    g ${cmd}  - Generate`);
        console.log(`    t ${cmd}  - Test`);
        console.log(`    d ${cmd}  - Deploy\n`);
      }
      
      prompt();
    });
  };
  
  prompt();
}

// ============================================================================
// MAIN
// ============================================================================

async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args.includes('--help') || args.includes('-h')) {
    console.log(HELP);
    process.exit(0);
  }

  const command = args[0];
  const options = { output: null, verbose: args.includes('--verbose') || args.includes('-v') };

  for (let i = 0; i < args.length; i++) {
    if ((args[i] === '--output' || args[i] === '-o') && args[i + 1]) {
      options.output = args[i + 1]; i++;
    }
  }

  const contractPath = args[1];

  switch (command) {
    case 'generate': case 'gen': case 'g':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdGenerate(contractPath, options); break;

    case 'dev': case 'd':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdDev(contractPath, options); break;

    case 'run': case 'r':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdRun(contractPath, options); break;

    case 'test': case 't':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdTest(contractPath, options); break;

    case 'deploy':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdDeploy(contractPath, options); break;

    case 'validate': case 'v':
      if (!contractPath) { console.error('‚ùå Missing contract path'); process.exit(1); }
      await cmdValidate(contractPath); break;

    case 'list': case 'ls': case 'l':
      await cmdList(); break;

    case 'stop':
      await cmdStop(); break;

    case 'studio':
      await cmdStudio(); break;

    default:
      if (command.endsWith('.reclapp.ts') || command.endsWith('.ts')) {
        await cmdGenerate(command, options);
      } else {
        console.error(`‚ùå Unknown command: ${command}`);
        console.log(HELP);
        process.exit(1);
      }
  }
}

main().catch(err => {
  console.error('‚ùå Error:', err.message);
  process.exit(1);
});
