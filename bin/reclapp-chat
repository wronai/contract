#!/usr/bin/env node
/**
 * Reclapp Chat - Interactive Contract Designer CLI
 * 
 * Uses shared chat-core module
 */

const readline = require('readline');
const fs = require('fs');
const path = require('path');
const { ReclappChat } = require('../lib/chat-core');

// Colors
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  dim: '\x1b[2m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function color(c, text) {
  return `${colors[c]}${text}${colors.reset}`;
}

// Create chat instance
const chat = new ReclappChat();
let lastSavedDir = '';

// Main
async function main() {
  console.log(`
${color('cyan', 'â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—')}
${color('cyan', 'â•‘')}              ${color('bright', 'ğŸ¤– RECLAPP CHAT - Contract Designer')}             ${color('cyan', 'â•‘')}
${color('cyan', 'â•‘')}         Interactive LLM-powered contract generation          ${color('cyan', 'â•‘')}
${color('cyan', 'â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')}

${color('dim', 'Model:')} ${chat.model} @ ${chat.ollamaHost}

${color('yellow', 'Commands:')}
  ${color('cyan', '/save [dir]')}      Save all formats (.rcl, .rcl.md, .ts)
  ${color('cyan', '/save-rcl [dir]')}  Save only .reclapp.rcl (minimized)
  ${color('cyan', '/save-md [dir]')}   Save only .rcl.md (readable)
  ${color('cyan', '/save-ts [dir]')}   Save only .reclapp.ts (executable)
  ${color('cyan', '/generate [dir|contract]')} Generate target/ from saved contract
  ${color('cyan', '/run [dir|contract]')}      Generate + run dev servers (API+Frontend)
  ${color('cyan', '/show')}            Show current contract
  ${color('cyan', '/show-ts')}         Show TypeScript version
  ${color('cyan', '/validate')}        Validate contract
  ${color('cyan', '/name <name>')}     Set project name
  ${color('cyan', '/clear')}           Clear conversation history
  ${color('cyan', '/model [name]')}    Show/switch model
  ${color('cyan', '/help')}            Show commands
  ${color('cyan', '/quit')}            Exit

${color('yellow', 'Formats:')}
  ${color('green', '.rcl.md')}       â†’ Readable (for users/AI, includes conversation)
  ${color('blue', '.reclapp.rcl')}  â†’ Minimized (for storage)
  ${color('magenta', '.reclapp.ts')}   â†’ Executable (for validation)

${color('dim', 'Start by describing what you want to build...')}
`);

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  const repoRoot = path.join(__dirname, '..');
  const reclappBin = path.join(__dirname, 'reclapp');

  const resolveContractPath = (arg) => {
    const isContractPath = (p) =>
      typeof p === 'string' &&
      (p.endsWith('.reclapp.rcl') || p.endsWith('.rcl') || p.endsWith('.rcl.md') || p.endsWith('.reclapp.ts') || p.endsWith('.ts') || p.endsWith('.md'));

    if (arg && isContractPath(arg)) {
      const resolved = path.resolve(arg);
      if (!fs.existsSync(resolved)) throw new Error(`Contract not found: ${resolved}`);
      return resolved;
    }

    const candidateDirs = [];
    if (arg) candidateDirs.push(arg);
    if (lastSavedDir) candidateDirs.push(lastSavedDir);
    candidateDirs.push(path.join('apps', chat.projectName));
    candidateDirs.push(`./${chat.projectName}`);

    for (const d of candidateDirs) {
      if (!d) continue;
      const dirAbs = path.resolve(d);
      const rcl = path.join(dirAbs, 'contracts', 'main.reclapp.rcl');
      const md = path.join(dirAbs, 'contracts', 'main.rcl.md');
      const ts = path.join(dirAbs, 'contracts', 'main.reclapp.ts');
      if (fs.existsSync(rcl)) return rcl;
      if (fs.existsSync(md)) return md;
      if (fs.existsSync(ts)) return ts;
    }

    throw new Error(
      `Could not find contract. Try /save ./apps/${chat.projectName} then /generate, or pass a contract path (e.g. /generate ./apps/${chat.projectName}/contracts/main.reclapp.rcl).`
    );
  };

  const prompt = () => {
    rl.question(`\n${color('green', 'ï¿½ï¿½ You:')} `, async (input) => {
      const trimmed = input.trim();
      
      if (!trimmed) {
        prompt();
        return;
      }

      // Handle commands
      if (trimmed.startsWith('/')) {
        const [cmd, ...args] = trimmed.slice(1).split(' ');
        const arg = args.join(' ').trim();
        
        switch (cmd.toLowerCase()) {
          case 'quit':
          case 'exit':
          case 'q':
            console.log(color('yellow', '\nğŸ‘‹ Goodbye!\n'));
            rl.close();
            process.exit(0);
            break;
            
          case 'help':
          case 'h':
            console.log(`
${color('yellow', 'Commands:')}
  ${color('cyan', '/save [dir]')}      Save all formats
  ${color('cyan', '/save-rcl [dir]')}  Save .reclapp.rcl
  ${color('cyan', '/save-md [dir]')}   Save .rcl.md (with conversation)
  ${color('cyan', '/save-ts [dir]')}   Save .reclapp.ts
  ${color('cyan', '/generate [dir|contract]')} Generate target/ from saved contract
  ${color('cyan', '/run [dir|contract]')}      Generate + run dev servers (API+Frontend)
  ${color('cyan', '/show')}            Show contract
  ${color('cyan', '/show-ts')}         Show TypeScript
  ${color('cyan', '/validate')}        Validate
  ${color('cyan', '/name <name>')}     Set project name
  ${color('cyan', '/clear')}           Clear history
  ${color('cyan', '/model [name]')}    Show/switch model
  ${color('cyan', '/quit')}            Exit
`);
            break;
            
          case 'show':
            if (chat.currentContract) {
              console.log(`\n${color('cyan', 'ğŸ“„ Current Contract:')}\n`);
              console.log(color('dim', 'â”€'.repeat(50)));
              console.log(chat.formatContract(chat.currentContract));
              console.log(color('dim', 'â”€'.repeat(50)));
            } else {
              console.log(color('yellow', 'âš ï¸ No contract yet. Start chatting to generate one.'));
            }
            break;
            
          case 'show-ts':
            if (chat.currentContract) {
              console.log(`\n${color('magenta', 'ğŸ”· TypeScript Version:')}\n`);
              console.log(color('dim', 'â”€'.repeat(50)));
              console.log(chat.toTypeScript());
              console.log(color('dim', 'â”€'.repeat(50)));
            } else {
              console.log(color('yellow', 'âš ï¸ No contract yet.'));
            }
            break;
            
          case 'validate':
            const result = chat.validateContract();
            if (result.valid) {
              console.log(color('green', `âœ… Valid! Entities: ${result.stats.entities}, Events: ${result.stats.events}, Enums: ${result.stats.enums}`));
            } else {
              console.log(color('red', `âŒ Issues:`));
              result.errors.forEach(e => console.log(color('yellow', `   â€¢ ${e}`)));
            }
            break;
            
          case 'save':
            if (!chat.currentContract) {
              console.log(color('red', 'âŒ No contract to save'));
              break;
            }
            const saveDir = arg || `./${chat.projectName}`;
            const saveResult = chat.saveContract(saveDir, 'all');
            if (saveResult.success) {
              lastSavedDir = saveDir;
              console.log(color('green', `âœ… Saved ${saveResult.files.length} files:`));
              saveResult.files.forEach(f => console.log(color('dim', `   ${f.path}`)));
            } else {
              console.log(color('red', `âŒ ${saveResult.error}`));
            }
            break;
            
          case 'save-rcl':
            if (!chat.currentContract) {
              console.log(color('red', 'âŒ No contract to save'));
              break;
            }
            const rclDir = arg || `./${chat.projectName}`;
            const rclResult = chat.saveContract(rclDir, 'rcl');
            if (rclResult.success) {
              lastSavedDir = rclDir;
              console.log(color('green', `âœ… Saved: ${rclResult.files[0]?.path}`));
            }
            break;
            
          case 'save-md':
            if (!chat.currentContract) {
              console.log(color('red', 'âŒ No contract to save'));
              break;
            }
            const mdDir = arg || `./${chat.projectName}`;
            const mdResult = chat.saveContract(mdDir, 'md');
            if (mdResult.success) {
              lastSavedDir = mdDir;
              console.log(color('green', `âœ… Saved: ${mdResult.files[0]?.path}`));
            }
            break;
            
          case 'save-ts':
            if (!chat.currentContract) {
              console.log(color('red', 'âŒ No contract to save'));
              break;
            }
            const tsDir = arg || `./${chat.projectName}`;
            const tsResult = chat.saveContract(tsDir, 'ts');
            if (tsResult.success) {
              lastSavedDir = tsDir;
              console.log(color('green', `âœ… Saved: ${tsResult.files[0]?.path}`));
            }
            break;

          case 'generate':
          case 'gen': {
            try {
              const contractPath = resolveContractPath(arg);
              console.log(color('dim', `\nğŸš€ Generating from: ${contractPath}`));
              const { spawn } = require('child_process');
              await new Promise((resolve, reject) => {
                const p = spawn(process.execPath, [reclappBin, 'generate', contractPath], {
                  cwd: repoRoot,
                  stdio: 'inherit',
                  shell: false
                });
                p.on('close', (code) => (code === 0 ? resolve() : reject(new Error(`generate exited with code ${code}`))));
              });
            } catch (e) {
              console.log(color('red', `âŒ ${e.message}`));
            }
            break;
          }

          case 'run': {
            try {
              const contractPath = resolveContractPath(arg);
              console.log(color('dim', `\nğŸš€ Running dev servers from: ${contractPath}`));
              console.log(color('dim', `   (Press Ctrl+C to stop)`));
              const { spawn } = require('child_process');
              rl.close();
              const p = spawn(process.execPath, [reclappBin, 'dev', contractPath], {
                cwd: repoRoot,
                stdio: 'inherit',
                shell: false
              });
              p.on('close', (code) => process.exit(code || 0));
              return;
            } catch (e) {
              console.log(color('red', `âŒ ${e.message}`));
            }
            break;
          }
            
          case 'name':
            if (arg) {
              chat.setProjectName(arg);
              console.log(color('green', `âœ… Project name set to: ${arg}`));
            } else {
              console.log(color('cyan', `ğŸ“ Current project: ${chat.projectName}`));
            }
            break;
            
          case 'clear':
            chat.clear();
            console.log(color('green', 'âœ… Conversation cleared'));
            break;
            
          case 'model':
            if (arg) {
              chat.setModel(arg);
              console.log(color('green', `âœ… Model set to: ${arg}`));
            } else {
              console.log(color('cyan', `ğŸ¤– Current model: ${chat.model}`));
            }
            break;
            
          default:
            console.log(color('yellow', `âš ï¸ Unknown command: /${cmd}. Type /help for commands.`));
        }
        
        prompt();
        return;
      }

      // Send to LLM
      console.log(color('dim', '\nâ³ Thinking...'));
      
      const response = await chat.chat(trimmed);
      
      if (response.error) {
        console.log(color('red', `\nâŒ Error: ${response.error}`));
      } else {
        console.log(`\n${color('blue', 'ğŸ¤– Assistant:')}\n`);
        console.log(response.response);
        
        if (response.contract) {
          console.log(`\n${color('green', 'âœ… Contract extracted!')}`);
          const validation = chat.validateContract();
          if (validation.valid) {
            console.log(color('dim', `   Entities: ${validation.stats.entities}, Events: ${validation.stats.events}, Enums: ${validation.stats.enums}`));
          } else {
            console.log(color('yellow', `   âš ï¸ ${validation.errors.join(', ')}`));
          }
        }
      }
      
      prompt();
    });
  };

  prompt();
}

main().catch(console.error);
