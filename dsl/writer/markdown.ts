/**
 * Markdown Contract Writer (.rcl.md)
 * Converts IR (Intermediate Representation) to .rcl.md format
 */

import { IR, Entity, EnumDef, EventDef, AlertDef, PipelineDef, DashboardDef, SourceDef, WorkflowDef, Message } from '../parser/markdown';

export interface WriteOptions {
  includeConversation?: boolean;
  includeTimestamp?: boolean;
  language?: 'pl' | 'en';
}

const LABELS = {
  pl: {
    properties: 'WÅ‚aÅ›ciwoÅ›Ä‡',
    value: 'WartoÅ›Ä‡',
    version: 'Wersja',
    author: 'Autor',
    license: 'Licencja',
    created: 'Utworzono',
    conversation: 'Rozmowa',
    entities: 'Encje',
    enums: 'Typy wyliczeniowe',
    events: 'Zdarzenia',
    alerts: 'Alerty',
    pipelines: 'PrzepÅ‚ywy danych',
    dashboards: 'Panele',
    sources: 'Å¹rÃ³dÅ‚a danych',
    workflows: 'PrzepÅ‚ywy pracy',
    api: 'Konfiguracja API',
    deployment: 'Deployment',
    env: 'Zmienne Å›rodowiskowe',
    generatedBy: 'Wygenerowano przez Reclapp Studio',
  },
  en: {
    properties: 'Property',
    value: 'Value',
    version: 'Version',
    author: 'Author',
    license: 'License',
    created: 'Created',
    conversation: 'Conversation',
    entities: 'Entities',
    enums: 'Enums',
    events: 'Events',
    alerts: 'Alerts',
    pipelines: 'Pipelines',
    dashboards: 'Dashboards',
    sources: 'Data Sources',
    workflows: 'Workflows',
    api: 'API Configuration',
    deployment: 'Deployment',
    env: 'Environment Variables',
    generatedBy: 'Generated by Reclapp Studio',
  },
};

export function writeMarkdownContract(
  ir: IR,
  conversation: Message[] = [],
  options: WriteOptions = {}
): string {
  const { includeConversation = true, includeTimestamp = true, language = 'pl' } = options;
  const L = LABELS[language];
  const lines: string[] = [];

  // Header
  lines.push(`# ${ir.app.name}`);
  lines.push('');

  if (ir.app.description) {
    lines.push(`> ${ir.app.description}`);
    lines.push('');
  }

  // Metadata table
  lines.push(`| ${L.properties} | ${L.value} |`);
  lines.push('|------------|---------|');
  lines.push(`| ${L.version} | ${ir.app.version || '1.0.0'} |`);
  if (ir.app.author) {
    lines.push(`| ${L.author} | ${ir.app.author} |`);
  }
  if (ir.app.license) {
    lines.push(`| ${L.license} | ${ir.app.license} |`);
  }
  if (includeTimestamp) {
    lines.push(`| ${L.created} | ${new Date().toISOString().split('T')[0]} |`);
  }
  lines.push('');
  lines.push('---');
  lines.push('');

  // Conversation
  if (includeConversation && conversation.length > 0) {
    lines.push(`## ðŸ’¬ ${L.conversation}`);
    lines.push('');

    for (const msg of conversation) {
      const emoji = msg.role === 'user' ? 'ðŸ§‘' : 'ðŸ¤–';
      const role = msg.role === 'user' ? 'User' : 'Assistant';
      lines.push(`### ${emoji} ${role} (${msg.timestamp})`);
      lines.push('');
      lines.push(msg.content);
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Entities
  if (ir.entities.length > 0) {
    lines.push(`## ðŸ“¦ ${L.entities}`);
    lines.push('');

    for (const entity of ir.entities) {
      lines.push(`### ${entity.name}`);
      lines.push('');
      lines.push('```yaml');
      lines.push(`# entity: ${entity.name}`);

      for (const field of entity.fields) {
        const modifiers: string[] = [];
        if (field.unique) modifiers.push('@unique');
        if (field.required) modifiers.push('@required');
        if (field.auto) modifiers.push('@auto');

        const modStr = modifiers.join(' ');
        const defaultStr = field.defaultValue ? ` = ${field.defaultValue}` : '';
        const descStr = field.description ? ` - ${field.description}` : '';

        let comment = `# ${modStr}${defaultStr}${descStr}`.trim();
        if (comment === '#') comment = '';

        const typeStr = field.type + (field.nullable && !field.type.endsWith('?') ? '?' : '');
        lines.push(`${field.name.padEnd(16)}: ${typeStr.padEnd(20)} ${comment}`.trimEnd());
      }

      lines.push('```');
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Enums
  if (ir.enums.length > 0) {
    lines.push(`## ðŸ·ï¸ ${L.enums}`);
    lines.push('');

    for (const enumDef of ir.enums) {
      lines.push('```yaml');
      lines.push(`# enum: ${enumDef.name}`);

      for (const value of enumDef.values) {
        const desc = value.description ? ` # ${value.description}` : '';
        lines.push(`- ${value.name}${desc}`);
      }

      lines.push('```');
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Events
  if (ir.events.length > 0) {
    lines.push(`## ðŸ“¡ ${L.events}`);
    lines.push('');

    for (const event of ir.events) {
      lines.push(`### ${event.name}`);
      lines.push('');
      lines.push('```yaml');
      lines.push(`# event: ${event.name}`);

      for (const field of event.fields) {
        lines.push(`${field.name.padEnd(16)}: ${field.type}`);
      }

      lines.push('```');
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Alerts
  if (ir.alerts.length > 0) {
    lines.push(`## ðŸš¨ ${L.alerts}`);
    lines.push('');

    for (const alert of ir.alerts) {
      lines.push(`### ${alert.name}`);
      lines.push('');
      lines.push('```yaml');
      lines.push(`# alert: ${alert.name}`);
      if (alert.entity) {
        lines.push(`entity: ${alert.entity}`);
      }
      lines.push(`when: ${alert.condition}`);
      lines.push(`notify: [${(alert.targets || []).join(', ')}]`);
      lines.push(`severity: ${alert.severity}`);
      if (alert.message) {
        lines.push(`message: "${alert.message}"`);
      }
      lines.push('```');
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Pipelines
  if (ir.pipelines.length > 0) {
    lines.push(`## ðŸ”„ ${L.pipelines}`);
    lines.push('');

    for (const pipeline of ir.pipelines) {
      lines.push(`### ${pipeline.name}`);
      lines.push('');
      lines.push('```yaml');
      lines.push(`# pipeline: ${pipeline.name}`);
      lines.push(`input: [${(pipeline.input || []).join(', ')}]`);
      lines.push(`output: ${pipeline.output}`);
      if (pipeline.schedule) {
        lines.push(`schedule: "${pipeline.schedule}"`);
      }
      if (pipeline.transform && pipeline.transform.length > 0) {
        lines.push(`transform: [${pipeline.transform.join(', ')}]`);
      }
      lines.push('```');
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Dashboards
  if (ir.dashboards.length > 0) {
    lines.push(`## ðŸ“Š ${L.dashboards}`);
    lines.push('');

    for (const dashboard of ir.dashboards) {
      lines.push(`### ${dashboard.name}`);
      lines.push('');
      lines.push('```yaml');
      lines.push(`# dashboard: ${dashboard.name}`);
      if (dashboard.entity) {
        lines.push(`entity: ${dashboard.entity}`);
      }
      lines.push(`metrics: [${(dashboard.metrics || []).join(', ')}]`);
      if (dashboard.stream) {
        lines.push(`stream: ${dashboard.stream}`);
      }
      if (dashboard.layout) {
        lines.push(`layout: ${dashboard.layout}`);
      }
      lines.push('```');
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Sources
  if (ir.sources.length > 0) {
    lines.push(`## ðŸ”Œ ${L.sources}`);
    lines.push('');

    for (const source of ir.sources) {
      lines.push(`### ${source.name}`);
      lines.push('');
      lines.push('```yaml');
      lines.push(`# source: ${source.name}`);
      lines.push(`type: ${source.type}`);
      if (source.url) {
        lines.push(`url: "${source.url}"`);
      }
      if (source.auth) {
        lines.push(`auth: ${source.auth}`);
      }
      if (source.cache) {
        lines.push(`cache: "${source.cache}"`);
      }
      lines.push('```');
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Workflows
  if (ir.workflows.length > 0) {
    lines.push(`## âš™ï¸ ${L.workflows}`);
    lines.push('');

    for (const workflow of ir.workflows) {
      lines.push(`### ${workflow.name}`);
      lines.push('');
      lines.push('```yaml');
      lines.push(`# workflow: ${workflow.name}`);
      lines.push(`trigger: ${workflow.trigger}`);
      lines.push(`steps: [${workflow.steps.join(', ')}]`);
      lines.push('```');
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // API
  if (ir.api) {
    lines.push(`## ðŸŒ ${L.api}`);
    lines.push('');
    lines.push('```yaml');
    lines.push('# api:');
    lines.push(`prefix: ${ir.api.prefix}`);
    lines.push(`auth: ${ir.api.auth}`);
    if (ir.api.rateLimit) {
      lines.push(`rateLimit: ${ir.api.rateLimit}`);
    }
    if (ir.api.cors) {
      lines.push(`cors: ${ir.api.cors}`);
    }
    lines.push('```');
    lines.push('');
    lines.push('---');
    lines.push('');
  }

  // Deployment
  if (ir.deployment) {
    lines.push(`## ðŸš€ ${L.deployment}`);
    lines.push('');
    lines.push('```yaml');
    lines.push('# deployment:');
    lines.push(`type: ${ir.deployment.type}`);
    lines.push(`database: ${ir.deployment.database}`);
    if (ir.deployment.cache) {
      lines.push(`cache: ${ir.deployment.cache}`);
    }
    lines.push('```');
    lines.push('');
    lines.push('---');
    lines.push('');
  }

  // Environment variables
  if (ir.env.length > 0) {
    lines.push(`## ðŸ” ${L.env}`);
    lines.push('');
    lines.push('```yaml');
    lines.push('# env:');

    for (const envVar of ir.env) {
      const modifiers: string[] = [];
      if (envVar.required) modifiers.push('@required');

      const modStr = modifiers.length > 0 ? ` # ${modifiers.join(' ')}` : '';
      const defaultStr = envVar.default ? ` = "${envVar.default}"` : '';

      lines.push(`${envVar.name.padEnd(20)}: ${envVar.type}${modStr}${defaultStr}`);
    }

    lines.push('```');
    lines.push('');
    lines.push('---');
    lines.push('');
  }

  // Footer
  if (ir.aiPlan) {
    lines.push('---');
    lines.push('');
    lines.push('## ðŸ¤– Plan AI');
    lines.push('');
    lines.push('```json:contract.ai.json');
    lines.push(JSON.stringify(ir.aiPlan, null, 2));
    lines.push('```');
    lines.push('');
  }

  lines.push(`*${L.generatedBy}*`);

  return lines.join('\n');
}

// Convert contract format to IR for writing
export function contractToIR(contract: any): IR {
  return {
    app: {
      name: contract.app?.name || contract.name || 'Unnamed',
      version: contract.app?.version || contract.version || '1.0.0',
      description: contract.app?.description || contract.description,
      author: contract.app?.author,
    },
    entities: (contract.entities || []).map((e: any) => ({
      name: e.name,
      fields: (e.fields || []).map((f: any) => ({
        name: f.name,
        type: f.rclType || mapTypeToRcl(f.type),
        required: f.required,
        unique: f.unique,
        auto: f.auto,
        nullable: !f.required,
        defaultValue: f.default,
        description: f.description,
      })),
    })),
    enums: contract.enums || [],
    events: contract.events || [],
    alerts: contract.alerts || [],
    pipelines: contract.pipelines || [],
    dashboards: contract.dashboards || [],
    sources: contract.sources || [],
    workflows: contract.workflows || [],
    api: contract.api,
    deployment: contract.deployment,
    env: contract.env || [],
    config: contract.config || {},
    aiPlan: contract.aiPlan,
  };
}

function mapTypeToRcl(type: string): string {
  const typeMap: Record<string, string> = {
    String: 'text',
    Int: 'int',
    Float: 'float',
    Boolean: 'bool',
    Date: 'date',
    DateTime: 'datetime',
    Json: 'json',
  };

  const mapped = typeMap[type];
  if (mapped) return mapped;

  // Preserve casing for relationships and potential custom types/enums
  if (type.startsWith('->')) return type;
  
  // If it looks like a custom type (starts with uppercase), keep it as is
  if (type.length > 0 && type[0] === type[0].toUpperCase()) return type;

  return type.toLowerCase();
}
