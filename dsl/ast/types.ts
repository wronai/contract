/**
 * Reclapp DSL AST Type Definitions
 * 
 * These types represent the Abstract Syntax Tree generated by the Peggy parser.
 * Used for validation, transformation, and code generation.
 */

// ============================================================================
// BASE TYPES
// ============================================================================

export interface Location {
  start: { offset: number; line: number; column: number };
  end: { offset: number; line: number; column: number };
}

export interface ASTNode {
  type: string;
  location: Location;
}

// ============================================================================
// PROGRAM ROOT
// ============================================================================

export interface Program extends ASTNode {
  type: 'Program';
  version: string;
  statements: Statement[];
}

export type Statement =
  | EntityDeclaration
  | EventDeclaration
  | PipelineDeclaration
  | AlertDeclaration
  | DashboardDeclaration
  | SourceDeclaration
  | DeviceDeclaration
  | WorkflowDeclaration
  | ConfigDeclaration;

// ============================================================================
// ENTITY TYPES
// ============================================================================

export interface EntityDeclaration extends ASTNode {
  type: 'EntityDeclaration';
  name: string;
  fields: FieldDeclaration[];
}

export interface FieldDeclaration extends ASTNode {
  type: 'FieldDeclaration';
  name: string;
  fieldType: TypeExpression;
  annotations: Annotation[];
  defaultValue?: LiteralValue;
}

export interface TypeExpression extends ASTNode {
  type: 'TypeExpression';
  baseType: string;
  nullable: boolean;
  isArray: boolean;
}

export interface Annotation extends ASTNode {
  type: 'Annotation';
  name: string;
  params: AnnotationParam[];
}

export interface AnnotationParam {
  name?: string;
  value: LiteralValue;
}

// ============================================================================
// EVENT TYPES
// ============================================================================

export interface EventDeclaration extends ASTNode {
  type: 'EventDeclaration';
  name: string;
  fields: EventField[];
}

export interface EventField extends ASTNode {
  type: 'EventField';
  name: string;
  fieldType: TypeExpression;
}

// ============================================================================
// PIPELINE TYPES
// ============================================================================

export interface PipelineDeclaration extends ASTNode {
  type: 'PipelineDeclaration';
  name: string;
  input?: DotPath;
  transforms?: string[];
  outputs?: string[];
  filter?: Expression;
  schedule?: StringLiteral;
}

// ============================================================================
// ALERT TYPES
// ============================================================================

export interface AlertDeclaration extends ASTNode {
  type: 'AlertDeclaration';
  name: StringLiteral;
  entity?: EntityReference;
  condition?: Expression;
  targets?: Target[];
  severity?: string;
  throttle?: StringLiteral;
}

export interface EntityReference {
  type: string;
  name?: StringLiteral;
}

export interface Target extends ASTNode {
  type: 'Target';
  protocol: string;
  path: string;
}

// ============================================================================
// DASHBOARD TYPES
// ============================================================================

export interface DashboardDeclaration extends ASTNode {
  type: 'DashboardDeclaration';
  name: StringLiteral;
  entity?: EntityReference;
  metrics?: string[];
  streamMode?: string;
  layout?: string;
  refreshInterval?: StringLiteral;
}

// ============================================================================
// SOURCE TYPES
// ============================================================================

export interface SourceDeclaration extends ASTNode {
  type: 'SourceDeclaration';
  name: string;
  sourceType?: string;
  url?: StringLiteral;
  auth?: string;
  mapping?: MappingEntry[];
  cacheDuration?: StringLiteral;
}

export interface MappingEntry {
  source: DotPath;
  target: string;
}

// ============================================================================
// DEVICE TYPES
// ============================================================================

export interface DeviceDeclaration extends ASTNode {
  type: 'DeviceDeclaration';
  name: StringLiteral;
  deviceType?: string;
  protocol?: string;
  topic?: StringLiteral;
  subscribe?: DotPath[];
  publish?: DotPath[];
  config?: ConfigEntryNode[];
}

export interface ConfigEntryNode {
  key: string;
  value: LiteralValue;
}

// ============================================================================
// WORKFLOW TYPES
// ============================================================================

export interface WorkflowDeclaration extends ASTNode {
  type: 'WorkflowDeclaration';
  name: string;
  trigger?: DotPath;
  steps?: StepDeclaration[];
}

export interface StepDeclaration extends ASTNode {
  type: 'StepDeclaration';
  name: string;
  action?: string;
  onSuccess?: string;
  onFailure?: string;
  timeout?: StringLiteral;
}

// ============================================================================
// CONFIG TYPES
// ============================================================================

export interface ConfigDeclaration extends ASTNode {
  type: 'ConfigDeclaration';
  name: string;
  entries: ConfigEntryNode[];
}

// ============================================================================
// EXPRESSION TYPES
// ============================================================================

export type Expression =
  | BinaryExpression
  | UnaryExpression
  | FunctionCall
  | DotPath
  | LiteralValue;

export interface BinaryExpression extends ASTNode {
  type: 'BinaryExpression';
  operator: string;
  left: Expression;
  right: Expression;
}

export interface UnaryExpression extends ASTNode {
  type: 'UnaryExpression';
  operator: string;
  argument: Expression;
}

export interface FunctionCall extends ASTNode {
  type: 'FunctionCall';
  name: string;
  arguments: Expression[];
}

export interface DotPath extends ASTNode {
  type: 'DotPath';
  path: string[];
  raw: string;
}

// ============================================================================
// LITERAL TYPES
// ============================================================================

export type LiteralValue =
  | StringLiteral
  | NumberLiteral
  | BooleanLiteral
  | NullLiteral
  | ArrayLiteral;

export interface StringLiteral extends ASTNode {
  type: 'StringLiteral';
  value: string;
}

export interface NumberLiteral extends ASTNode {
  type: 'NumberLiteral';
  value: number;
}

export interface BooleanLiteral extends ASTNode {
  type: 'BooleanLiteral';
  value: boolean;
}

export interface NullLiteral extends ASTNode {
  type: 'NullLiteral';
  value: null;
}

export interface ArrayLiteral extends ASTNode {
  type: 'ArrayLiteral';
  items: LiteralValue[];
}

// ============================================================================
// UTILITY TYPES
// ============================================================================

export interface ParseResult {
  success: boolean;
  ast?: Program;
  errors?: ParseError[];
}

export interface ParseError {
  message: string;
  location: Location;
  expected?: string[];
  found?: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

export interface ValidationError {
  code: string;
  message: string;
  location?: Location;
  node?: ASTNode;
}

export interface ValidationWarning {
  code: string;
  message: string;
  location?: Location;
  suggestion?: string;
}

// ============================================================================
// SEMANTIC MODEL (Post-validation)
// ============================================================================

export interface SemanticModel {
  entities: Map<string, ResolvedEntity>;
  events: Map<string, ResolvedEvent>;
  pipelines: Map<string, ResolvedPipeline>;
  alerts: Map<string, ResolvedAlert>;
  dashboards: Map<string, ResolvedDashboard>;
  sources: Map<string, ResolvedSource>;
  devices: Map<string, ResolvedDevice>;
  workflows: Map<string, ResolvedWorkflow>;
}

export interface ResolvedEntity {
  name: string;
  fields: ResolvedField[];
  indexes: string[];
  relationships: EntityRelationship[];
}

export interface ResolvedField {
  name: string;
  type: ResolvedType;
  required: boolean;
  unique: boolean;
  generated: boolean;
  defaultValue?: any;
  validation?: FieldValidation;
}

export interface ResolvedType {
  primitive: string;
  nullable: boolean;
  array: boolean;
  reference?: string;
}

export interface FieldValidation {
  pattern?: string;
  min?: number;
  max?: number;
  enum?: string[];
}

export interface EntityRelationship {
  type: 'oneToOne' | 'oneToMany' | 'manyToMany';
  target: string;
  field: string;
}

export interface ResolvedEvent {
  name: string;
  fields: ResolvedField[];
  streamName: string;
}

export interface ResolvedPipeline {
  name: string;
  inputStream: string;
  transforms: TransformStep[];
  outputs: OutputTarget[];
  schedule?: string;
}

export interface TransformStep {
  name: string;
  type: 'builtin' | 'custom';
  config?: Record<string, any>;
}

export interface OutputTarget {
  type: 'dashboard' | 'device' | 'alert' | 'store';
  target: string;
}

export interface ResolvedAlert {
  name: string;
  entityType: string;
  condition: CompiledCondition;
  targets: AlertTarget[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  throttle?: number;
}

export interface CompiledCondition {
  expression: string;
  evaluate: (context: Record<string, any>) => boolean;
}

export interface AlertTarget {
  type: 'email' | 'slack' | 'mqtt' | 'webhook' | 'sms';
  address: string;
  config?: Record<string, any>;
}

export interface ResolvedDashboard {
  name: string;
  entityType: string;
  metrics: DashboardMetric[];
  layout: DashboardLayout;
  streaming: boolean;
  refreshMs?: number;
}

export interface DashboardMetric {
  name: string;
  type: 'count' | 'sum' | 'avg' | 'distribution' | 'timeseries';
  field?: string;
  aggregation?: string;
}

export interface DashboardLayout {
  type: 'grid' | 'flex' | 'tabs';
  columns?: number;
  widgets: WidgetConfig[];
}

export interface WidgetConfig {
  type: string;
  metric: string;
  position: { row: number; col: number; width: number; height: number };
}

export interface ResolvedSource {
  name: string;
  type: 'rest' | 'graphql' | 'database' | 'file';
  url: string;
  auth?: AuthConfig;
  mapping: FieldMapping[];
  cache?: CacheConfig;
}

export interface AuthConfig {
  type: 'none' | 'basic' | 'bearer' | 'oauth2' | 'apiKey';
  credentials?: string;
}

export interface FieldMapping {
  source: string;
  target: string;
  transform?: string;
}

export interface CacheConfig {
  enabled: boolean;
  ttlSeconds: number;
}

export interface ResolvedDevice {
  name: string;
  type: string;
  protocol: 'mqtt' | 'coap' | 'http' | 'websocket';
  topics: DeviceTopic[];
  config: Record<string, any>;
}

export interface DeviceTopic {
  name: string;
  direction: 'subscribe' | 'publish';
  eventType: string;
}

export interface ResolvedWorkflow {
  name: string;
  trigger: WorkflowTrigger;
  steps: WorkflowStep[];
}

export interface WorkflowTrigger {
  type: 'event' | 'schedule' | 'manual';
  source: string;
}

export interface WorkflowStep {
  name: string;
  action: string;
  transitions: StepTransition[];
  timeout?: number;
}

export interface StepTransition {
  condition: 'success' | 'failure' | 'timeout';
  target: string | 'end';
}
